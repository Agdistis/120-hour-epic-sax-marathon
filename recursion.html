<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="120 hour epic">
  <title>Recursion</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
</head>
<body>
<div class="container-fluid">
<div class="row-fluid">
<div class="span12"><div class="top-nav"><a href="index.html">← index</a></div>
<header>
<h1 class="title">Recursion</h1>
<h2 class="author">120 hour epic</h2>
<h3 class="date">sax marathon</h3>
</header>
<section class="level2" id="synopsis">
<h2>Synopsis</h2>
<p>Recursion is the low-level implementation strategy for many functional algorithms and functions.</p>
<ul>
<li>TODO</li>
<li>Wat we talk about</li>
</ul>
</section>
<section class="level2" id="get-the-project">
<h2>Get the project</h2>
<p>TODO</p>
</section>
<section class="level2" id="recap">
<h2>Recap</h2>
<p>This chapter talks a lot about collections and we’ll need the functions <code>first</code> and <code>rest</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">doc</span> <span class="kw">first</span>)
(<span class="kw">doc</span> <span class="kw">rest</span>)
(<span class="kw">first</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])  <span class="co">;=&gt; 1</span>
(<span class="kw">first</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)) <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])   <span class="co">;=&gt; (2 3 4)</span>
(<span class="kw">rest</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))  <span class="co">;=&gt; (2 3 4)</span>
(<span class="kw">rest</span> [<span class="dv">1</span>])         <span class="co">;=&gt; ()</span>
(<span class="kw">rest</span> [])          <span class="co">;=&gt; ()</span></code></pre>
<p><code>first</code> gets the first element of a sequence, and <code>rest</code> gets all but the first element.</p>
</section>
<section class="level2" id="recursion">
<h2>Recursion</h2>
<p>So far we’ve manipulated collections with functions like <code>map</code>, <code>filter</code> and <code>for</code>. How do they work? They are all based on <em>recursion</em>. Recursion is the low-level method of iteration found in functional languages. While the higher-level functions like <code>map</code> are usually nicer to use than implementing the equivalent algorithm with recursion ourselves, there are often situations when the structure of the algorithm or the data it operates on is such that the existing higher-level functions do not quite work on it.</p>
<section class="level3" id="lists-are-recursive-structures">
<h3>Lists are recursive structures</h3>
<p>Let’s look at the function <code>cons</code>. It takes two parameters, a value and a sequence, and returns a new sequence with the value added to the front of the original sequence. For an example, to construct the sequence <code>(1 2 3 4)</code>, we could write:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">cons</span> <span class="dv">1</span>
      (<span class="kw">cons</span> <span class="dv">2</span>
            (<span class="kw">cons</span> <span class="dv">3</span>
                  (<span class="kw">cons</span> <span class="dv">4</span>
                        nil))))
<span class="co">;=&gt; (1 2 3 4)</span></code></pre>
<p><code>nil</code> is the empty sequence.</p>
<p>To process this nested structure suggests that we should first process the first element of the sequence, and then do the operation again on the rest of the sequence. This is actually the general structure of <em>linear recursion</em>. As a concrete example, let’s look at how to implement <code>sum</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum </span>[coll]
  (<span class="kw">if</span> (<span class="kw">empty?</span> coll)
    <span class="dv">0</span>
    (<span class="kw">+</span> (<span class="kw">first</span> coll)
       (sum (<span class="kw">rest</span> coll)))))

(sum [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; 10</span></code></pre>
<p>The <em>sum</em> of a sequence is: - 0, if the sequence is empty, or - the <em>first</em> element of the sequence <em>added</em> to the <em>sum</em> of the <em>rest</em> of the sequence.</p>
<p>Imagine an arrow drawn from the second <em>sum</em> to the first <em>sum</em>. This is the recursive nature of the algorithm.</p>
<p>The call to <code>sum</code> begins by inspecting <code>coll</code>. If <code>coll</code> is empty, <code>sum</code> immediately returns 0. If <code>coll</code> is not empty, <code>sum</code> takes its first element and adds it to the sum of the rest of the elements of <code>coll</code>. The value 0 is the base case of the algorithm, which determines when the calculation stops. If we did not have a base case, the calculation would continue infinitely.</p>
<section class="alert alert-success">
<h3>
Exercise 1
</h3>
<p>Write the function <code>(product coll)</code> that computes the product of a collection of values.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(product [])        <span class="co">;=&gt; 1  ; special case </span>
(product [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; 6</span>
(product [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; 24</span>
(product [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>])   <span class="co">;=&gt; 0</span>
(product #{<span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>})  <span class="co">;=&gt; 24 ; works for sets too!</span></code></pre>
</section>
<p>To get a better grasp on what <code>sum</code> does, let’s see how it’s evaluated.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (sum &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))
<span class="kw">=</span>   (sum (<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> (<span class="kw">cons</span> <span class="dv">4</span> nil)))))
<span class="co">;=&gt; (+ 1 (sum (cons 2 (cons 3 (cons 4 nil)))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (sum (cons 3 (cons 4 nil)))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 (sum (cons 4 nil)))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 (+ 4 (sum nil)))))</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 (+ 4 0))))        ; (empty? nil) is true, so (sum nil) ;=&gt; 0</span>
<span class="co">;=&gt; (+ 1 (+ 2 (+ 3 4)))</span>
<span class="co">;=&gt; (+ 1 (+ 2 7))</span>
<span class="co">;=&gt; (+ 1 9)</span>
<span class="co">;=&gt; 10</span></code></pre>
<p>Note that we expanded the list <code>'(1 2 3 4)</code> to its <code>cons</code> form. If we take a closer look at that form and the line with comment above, we’ll see why:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">   (<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> (<span class="kw">cons</span> <span class="dv">4</span> nil))))
...
<span class="co">;=&gt; (+    1 (+    2 (+    3 (+    4   0))))</span></code></pre>
<p>We replaced the <code>cons</code> operation in the recursive structure with <code>+</code> and <code>nil</code> with <code>0</code>. That is, we transformed the data structure into a calculation with the same form but different result.</p>
<p>From this we get the general template for linear recursion over collections:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> eats-coll </span>[coll]
  (<span class="kw">if</span> (<span class="kw">empty?</span> coll)
    ...
    (... (<span class="kw">first</span> coll) ... (eats-coll (<span class="kw">rest</span> coll)))))</code></pre>
<p>The first branch of the <code>if</code> is the base case and determines the value of <code>eats-coll</code> when given an empty collection. The second branch determines what operation to apply on the elements of the collection.</p>
<p>We call this kind of computation <em>linear</em> because the expression it constructs grows linearly with the size of input.</p>
<section class="alert alert-success">
<h3>
Exercise 2
</h3>
<p>Write down the evaluation of <code>(product [1 2 4])</code> like we did for <code>sum</code> above.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 3
</h3>
<p>Compute the last element of a sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(last-element [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; 3</span>
(last-element [<span class="dv">2</span> <span class="dv">5</span>])   <span class="co">;=&gt; 5</span></code></pre>
<p>Hint: what is the base case here? How can you check if we’re there?</p>
</section>
</section>
<section class="level3" id="stopping-before-the-end">
<h3>Stopping before the end</h3>
<p>Sometimes you can find the answer before hitting the base case. For example, the following function checks if a sequence contains only numbers. If we find something that isn’t a number on the way through, we can immediately stop and return <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> only-numbers</span>? [coll]
  (<span class="kw">cond</span>
   (<span class="kw">empty?</span> coll)
     true                        <span class="co">; the empty sequence contains only numbers</span>
   (<span class="kw">number?</span> (<span class="kw">first</span> coll))
     (only-numbers? (<span class="kw">rest</span> coll)) <span class="co">; we got a number, let&#39;s check the rest</span>
   <span class="kw">:else</span>
     false))                     <span class="co">; it wasn&#39;t a number so we have our answer</span></code></pre>
<p>Here the recursion stops if we hit the base case (empty collection) or if we find a non-number.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(only-numbers? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])    <span class="co">;=&gt; true</span>
(only-numbers? [<span class="dv">1</span> <span class="dv">2</span> <span class="kw">:D</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; false</span></code></pre>
<p>Let’s have a closer look at the evaluation of the second line:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">   (only-numbers? [<span class="dv">1</span> <span class="dv">2</span> <span class="kw">:D</span> <span class="dv">3</span> <span class="dv">4</span>])
<span class="co">;=&gt; (only-numbers? [2 :D 3 4])</span>
    <span class="co">; (number? 1) ;=&gt; true, so we now need to check if all the rest are numbers.</span>
<span class="co">;=&gt; (only-numbers? [:D 3 4]) ; because (number? 2) ;=&gt; true</span>
<span class="co">;=&gt; false                    ; because (number? :D) ;=&gt; false</span></code></pre>
<section class="alert alert-success">
<h3>
Exercise 4
</h3>
<p>Write the function <code>(sequence-contains? elem collection)</code> that returns <code>true</code> if the given sequence contains the given value, otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(sequence-contains? <span class="dv">3</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; true</span>
(sequence-contains? <span class="dv">3</span> [<span class="dv">4</span> <span class="dv">7</span> <span class="dv">9</span>]) <span class="co">;=&gt; false</span>
(sequence-contains? <span class="kw">:pony</span> [])  <span class="co">;=&gt; false</span></code></pre>
<p>Hint: remember to stop searching when you find it.</p>
</section>
</section>
<section class="level3" id="recursing-over-many-sequences">
<h3>Recursing over many sequences</h3>
<p>The template for linear recursion is very simple and is often <em>too</em> simple. For an example, consider the function <code>(first-in val seq-1 seq-2)</code>, which returns <code>1</code> if the value <code>val</code> is found first in <code>seq-1</code> and <code>2</code> if in <code>seq-2</code>. If <code>val</code> is not found in either sequence, <code>first-in</code> returns <code>0</code>. <code>val</code> must not be <code>nil</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> first-in </span>[<span class="kw">val</span> seq<span class="dv">-1</span> seq<span class="dv">-2</span>]
  (<span class="kw">cond</span>
    (<span class="kw">and</span> (<span class="kw">empty?</span> seq<span class="dv">-1</span>) (<span class="kw">empty?</span> seq<span class="dv">-2</span>)) <span class="dv">0</span>
    (<span class="kw">=</span> (<span class="kw">first</span> seq<span class="dv">-1</span>) <span class="kw">val</span>) <span class="dv">1</span>
    (<span class="kw">=</span> (<span class="kw">first</span> seq<span class="dv">-2</span>) <span class="kw">val</span>) <span class="dv">2</span>
    <span class="kw">:else</span> (first-in <span class="kw">val</span> (<span class="kw">rest</span> seq<span class="dv">-1</span>) (<span class="kw">rest</span> seq<span class="dv">-2</span>))))</code></pre>
<p>There’s an obvious reason why <code>first-in</code> doesn’t fit our template for linear recursion: it has three parameters, whereas the template only takes one. We can ignore the first parameter for our purposes, since it does not have bearing on the recursive structure of the computation. <code>first-in</code> is linearly recursive on both its sequence parameters, though. There’s actually a way to make <code>first-in</code> fit into our template: transform its parameters into a single sequence with <code>map vector seq-1 seq-2</code>. This means our template is probably enough for us as long as we remember that it does not preclude recursing over multiple sequences.</p>
<section class="alert alert-success">
<h3>
Exercise 5
</h3>
<p>Write the function <code>(seq= seq-1 seq-2)</code> that compares two sequences for equality.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(seq= [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>] &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>))  <span class="co">;=&gt; true</span>
(seq= [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; false</span>
(seq= [<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>] [])        <span class="co">;=&gt; false</span></code></pre>
</section>
</section>
<section class="level3" id="recursion-on-numbers">
<h3>Recursion on numbers</h3>
<p>Another common data structure to recurse over are numbers. (Even though you might not think of numbers as data structures!) Recursing over numbers is very similar to recursing over sequences. As an example, let’s define a function to calculate the factorial of a number. (Factorial of n is 1 * 2 * … * (n-1) * n.)</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> factorial </span>[n]
  (<span class="kw">if</span> (zero? n)
    <span class="dv">1</span>
    (<span class="kw">*</span> n (factorial (<span class="kw">dec</span> n)))))</code></pre>
<p>The <code>factorial</code> function looks a lot like <code>sum</code>. Given the number <code>n</code>, We have the base case (return 1 if <code>n</code> is zero) and the recursive branch, which multiplies <code>n</code> with the factorial of <code>(dec n)</code>, that is, <code>(- n 1)</code>. To verify that this function really does implement the definition of factorial properly, we can look at how it is evaluated:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (factorial <span class="dv">4</span>)
<span class="co">;=&gt; (* 4 (factorial 3))</span>
<span class="co">;=&gt; (* 4 (* 3 (factorial 2)))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (factorial 1))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 (factorial 0)))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 1)))) ; Base case reached</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 1)))</span>
<span class="co">;=&gt; (* 4 (* 3 2))</span>
<span class="co">;=&gt; (* 4 6)</span>
<span class="co">;=&gt; 24</span></code></pre>
<p>The line where the base case is reached shows that the function does evaluate to the mathematical expression we wanted.</p>
<p>Let’s look a bit closer at how sequences and numbers are related. Where a sequence is <em>cons</em>tructed, numbers are <em>inc</em>remented, and where a sequence is destructured with <code>rest</code>, a number is decremented with <code>dec</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">inc</span>    (<span class="kw">inc</span>    (<span class="kw">inc</span>    <span class="dv">0</span>)))   <span class="co">;=&gt; 3</span>
(<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> nil))) <span class="co">;=&gt; (1 2 3)</span>

(<span class="kw">dec</span>  (<span class="kw">dec</span>  (<span class="kw">dec</span>  <span class="dv">3</span>)))       <span class="co">;=&gt; 0</span>
(<span class="kw">rest</span> (<span class="kw">rest</span> (<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))) <span class="co">;=&gt; ()</span></code></pre>
<p>Sequences store more information than numbers – the elements – but otherwise the expressions above are very similar. (The numbers actually encode the length of the sequence. Conversely, sequences can be used to encode numbers. Benjamin Pierce’s <a href="http://www.cis.upenn.edu/~bcpierce/sf/Basics.html#nat">Software Foundations</a> is recommended reading if you’re interested in more off-topic esoterica.) With this relationship, we can make the evaluation of <code>(factorial 4)</code> even more similar to our example of <code>sum</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (factorial (<span class="kw">inc</span> (<span class="kw">inc</span> (<span class="kw">inc</span> (<span class="kw">inc</span> <span class="dv">0</span>))))) <span class="co">; Unwrap inc with dec</span>
<span class="co">;=&gt; (* 4 (factorial (inc (inc (inc 0))))) ; like cons with rest</span>
<span class="co">;=&gt; (* 4 (* 3 (factorial (inc (inc 0))))) ; almost a haiku</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (factorial (inc 0)))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 (factorial 0)))))</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 (* 1 1))))             ; Base case reached</span>
<span class="co">;=&gt; (* 4 (* 3 (* 2 1)))</span>
<span class="co">;=&gt; (* 4 (* 3 2))</span>
<span class="co">;=&gt; (* 4 6)</span>
<span class="co">;=&gt; 24</span></code></pre>
<p>Let’s define the general template for recursion over (natural) numbers, like we did for sequences.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> eats-numbers </span>[n]
  (<span class="kw">if</span> (zero? n)
    ...
    (... n ... (eats-numbers (<span class="kw">dec</span> n)))))</code></pre>
<section class="alert alert-success">
<h3>
Exercise 6
</h3>
<p>Write the function <code>power</code> that computes the mathematical expression n <sup>k</sup>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(power <span class="dv">2</span> <span class="dv">2</span>) <span class="co">;=&gt; 4</span>
(power <span class="dv">5</span> <span class="dv">3</span>) <span class="co">;=&gt; 125</span>
(power <span class="dv">7</span> <span class="dv">0</span>) <span class="co">;=&gt; 1</span>
(power <span class="dv">0</span> <span class="dv">10</span>) <span class="co">;=&gt; 0</span></code></pre>
</section>
</section>
<section class="level3" id="nonlinear-recursion">
<h3>Nonlinear recursion</h3>
<p>There are other recursive computations besides linear recursion. Another common type is <em>tree recursion</em>. Here <em>tree</em> refers again to the shape of the computation. The natural use for tree recursion is with hierarchical data structures, which we will come back to later. Tree recursion can be illustrated with simple processes over numbers. For an example, let’s look at how to compute the following integer series:</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo></mrow></math> - <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>&lt;</mo><mn>3</mn></mrow></math>, - <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>*</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><mo>*</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></math> otherwise.</p>
<p>Translating this to Clojure gives us the following program:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> f </span>[n]
  (<span class="kw">if</span> (<span class="kw">&lt;</span> n <span class="dv">3</span>)
    n
    (<span class="kw">+</span>      (f (<span class="kw">-</span> n <span class="dv">1</span>))
       (<span class="kw">*</span> <span class="dv">2</span> (f (<span class="kw">-</span> n <span class="dv">2</span>)))
       (<span class="kw">*</span> <span class="dv">3</span> (f (<span class="kw">-</span> n <span class="dv">3</span>))))))</code></pre>
<p>(The odd alignment is for clarity.) Consider how this function evaluates:</p>
<p>!tree-recursion.png|border=0!</p>
<p>It is easy to see that the computation forms a tree structure.</p>
<section class="alert alert-success">
<h3>
Exercise 7
</h3>
<p>Compute the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>th <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci number</a>. The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>th Fibonacci number, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mi>n</mi></msub></mrow></math>, is defined as:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow></math></li>
</ul>
<p>Write the function <code>(fib n)</code> which returns <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mi>n</mi></msub></mrow></math>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(fib <span class="dv">0</span>) <span class="co">;=&gt; 0</span>
(fib <span class="dv">1</span>) <span class="co">;=&gt; 1</span>
(fib <span class="dv">2</span>) <span class="co">;=&gt; 1</span>
(fib <span class="dv">3</span>) <span class="co">;=&gt; 2</span>
(fib <span class="dv">4</span>) <span class="co">;=&gt; 3</span>
(fib <span class="dv">5</span>) <span class="co">;=&gt; 5</span>
(fib <span class="dv">6</span>) <span class="co">;=&gt; 8</span>
...
(fib <span class="dv">10</span>) <span class="co">;=&gt; 55</span></code></pre>
</section>
</section>
<section class="level3" id="sequence-operations">
<h3>Sequence operations</h3>
<p>This is the code for the recursive function <code>repeat</code> that generates a list with one element repeated a number of times.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> repeat </span>[what-to-repeat how-many-times]
  (<span class="kw">when</span> (<span class="kw">pos?</span> how-many-times)
    (<span class="kw">cons</span> what-to-repeat
          (<span class="kw">repeat</span> what-to-repeat (<span class="kw">dec</span> how-many-times)))))

(<span class="kw">repeat</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">;=&gt; (2 2 2)</span></code></pre>
<p>In the following exercises you should use recursion to build lists. Do not use <code>for</code>.</p>
<section class="alert alert-success">
<h3>
Exercise 8
</h3>
<p>Write the function <code>(my-range up-to)</code> that works like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-range <span class="dv">0</span>)  <span class="co">;=&gt; nil</span>
(my-range <span class="dv">1</span>)  <span class="co">;=&gt; (0)</span>
(my-range <span class="dv">2</span>)  <span class="co">;=&gt; (1 0)</span>
(my-range <span class="dv">3</span>)  <span class="co">;=&gt; (2 1 0)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 9
</h3>
<p>Write the function <code>map-1</code> that works like <code>map</code> but supports only one argument sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(map<span class="dv">-1</span> <span class="kw">identity</span> [])                 <span class="co">;=&gt; ()</span>
(map<span class="dv">-1</span> <span class="kw">identity</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])            <span class="co">;=&gt; (1 2 3)</span>
(map<span class="dv">-1</span> <span class="kw">count</span> [<span class="st">&quot;aaa&quot;</span> <span class="st">&quot;bb&quot;</span> <span class="st">&quot;cccc&quot;</span>])   <span class="co">;=&gt; (3 2 4)</span>
(map<span class="dv">-1</span> <span class="kw">first</span> [[<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">4</span>] [<span class="dv">7</span> <span class="dv">12</span> <span class="dv">28</span>]]) <span class="co">;=&gt; (1 4 7)</span>
(map<span class="dv">-1</span> zero? [<span class="dv">0</span> <span class="dv">2</span> <span class="dv">0</span> <span class="dv">13</span> <span class="dv">4</span> <span class="dv">0</span>])        <span class="co">;=&gt; (true false true false false true)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 10
</h3>
<p>Write the function <code>snip-many</code> that takes a sequence like <code>(0 1 2 :snip 3 4 5 :snip 6)</code> and returns a sequence of sequences like:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">((<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>) (<span class="dv">6</span>))</code></pre>
<p><em>Hint</em>: remember <code>snip</code>.</p>
<p>More examples:</p>
<pre><code>(snip-many [1 2 3])                   ;=&gt; ((1 2 3))
(snip-many [])                        ;=&gt; (())
(snip-many [:snip 1 2 :snip 3 :snip]) ;=&gt; (() (1 2) (3) ())
(snip-many [:snip])                   ;=&gt; (() ())</code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 11
</h3>
<p>Write the functions <code>tails</code> and <code>inits</code> that return all the suffixes and prefixes of a sequence, respectively. Examples:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(tails [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])   <span class="co">;=&gt; ((1 2 3 4) (2 3 4) (3 4) (4) ())</span>
(inits [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])   <span class="co">;=&gt; (() (1) (1 2) (1 2 3) (1 2 3 4))</span></code></pre>
<p>You can output the tails and inits in any order you like. That is,</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(inits [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])   <span class="co">;=&gt; ((1 2) () (1 2 3) (1) (1 2 3 4))</span></code></pre>
<p>is perfectly acceptable.</p>
<p><em>Hint:</em> You can use <code>reverse</code> and <code>map-1</code>.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 12
</h3>
<p>Write the function <code>split-into-monotonics</code> that takes a sequence and returns the sequence split into monotonic pieces. Examples:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(split-into-monotonic [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">0</span>])   <span class="co">;=&gt; ((0 1 2) (1 0))</span>
(split-into-monotonic [<span class="dv">0</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">3</span>]) <span class="co">;=&gt; ((0 5) (4 7) (1 3))</span></code></pre>
</section>
</section>
<section class="level3" id="passing-state">
<h3>Passing state</h3>
<p>Sometimes when recursing over a structure we want to keep track of something. For an example, we might want to count how many elements we have processed, or how many <code>:D</code> keywords we have seen. How do we do this, in the absence of state in our language? (Or at least in the absence of instructions on how to use state on these pages!)</p>
<p>The answer is two-fold: we store the state explicitly in a parameter we pass back to ourselves on each recursion, and we hide the state from the users of our function by using a helper function that we give an initial empty state to as a parameter.</p>
<p>Here’s an example of a function that counts how many times a sequence contains a given value:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> my-count-helper </span>[n <span class="kw">val</span> coll]
  (<span class="kw">if</span> (<span class="kw">empty?</span> coll)
    n
    (<span class="kw">let</span> [new-count (<span class="kw">if</span> (<span class="kw">=</span> <span class="kw">val</span> (<span class="kw">first</span> coll))
                      (<span class="kw">inc</span> n)
                      n)]
      (my-count-helper
        new-count
        <span class="kw">val</span>
        (<span class="kw">rest</span> coll)))))

(<span class="kw">defn</span><span class="fu"> my-count </span>[<span class="kw">val</span> coll]
  (my-count-helper <span class="dv">0</span> <span class="kw">val</span> coll))</code></pre>
<p>First, we define a helper function, <code>my-count-helper</code>. It takes three parameters: <code>n</code>, which keeps count of how many recursions have been made, <code>val</code>, which is the value we are looking for, and <code>coll</code>, which the function recurses over. With this helper function, our definition of <code>my-count</code> is a simple call to <code>my-count-helper</code> with <code>n</code> initialized to 0. This way users of <code>my-count</code> do not need to provide the initialization argument for <code>n</code>.</p>
<section class="alert alert-success">
<h3>
Exercise 13
</h3>
<p>Write the function <code>rotations</code> that, when given a sequence, returns all the rotations of that sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(rotations [])                  <span class="co">;=&gt; ()</span>
(rotations [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])             <span class="co">;=&gt; ((1 2 3) (2 3 1) (3 1 2))</span>
(rotations [<span class="kw">:a</span> <span class="kw">:b])</span>             <span class="co">;=&gt; ((:a :b) (:b :a))</span>
(rotations [<span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span>])           <span class="co">;=&gt; ((1 5 9 2) (2 1 5 9) (9 2 1 5) (5 9 2 1))</span>
(<span class="kw">count</span> (rotations [<span class="dv">6</span> <span class="dv">5</span> <span class="dv">8</span> <span class="dv">9</span> <span class="dv">2</span>])) <span class="co">;=&gt; 5</span></code></pre>
<p>The order of rotations does not matter.</p>
<p>You can use <code>concat</code> in your function. It concatenates two sequences: <sub>~</sub> {.clojure} (concat [1 2 3] [:a :b :c]) ;=&gt; (1 2 3 :a :b :c) (concat [1 2] [3 4 5 6]) ;=&gt; (1 2 3 4 5 6) <sub>~</sub></p>
</section>
<section class="alert alert-success">
<h3>
Exercise 14
</h3>
<p>Write the function <code>my-frequencies</code> that computes a map of how many times each element occurs in a sequence. E.g.:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(my-frequencies []) <span class="co">;=&gt; {}</span>
(my-frequencies [<span class="kw">:a</span> <span class="st">&quot;moi&quot;</span> <span class="kw">:a</span> <span class="st">&quot;moi&quot;</span> <span class="st">&quot;moi&quot;</span> <span class="kw">:a</span> <span class="dv">1</span>]) <span class="co">;=&gt; {:a 3, &quot;moi&quot; 3, 1 1}</span></code></pre>
<p>You’ll want to structure your code like this:</p>
<pre><code>(defn frequencies-helper [freqs coll]
  ...)

(defn my-frequencies [coll]
  (frequencies-helper {} coll))</code></pre>
<p>Where <code>frequencies-helper</code> is the recursive function.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 15
</h3>
<p>Write the function <code>un-frequencies</code> which takes a map produced by <code>my-frequencies</code> and generates a sequence with the corresponding numbers of different elements.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(un-frequencies {<span class="kw">:a</span> <span class="dv">3</span> <span class="kw">:b</span> <span class="dv">2</span> <span class="st">&quot;^_^&quot;</span> <span class="dv">1</span>})             <span class="co">;=&gt; (:a :a :a &quot;^_^&quot; :b :b)</span>
(un-frequencies (my-frequencies [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span> <span class="kw">:a]))</span>  <span class="co">;=&gt; (:a :a :b :c)</span>
(my-frequencies (un-frequencies {<span class="kw">:a</span> <span class="dv">100</span> <span class="kw">:b</span> <span class="dv">10</span>})) <span class="co">;=&gt; {:a 100 :b 10}</span></code></pre>
<p>The order of elements in the output sequence doesn’t matter.</p>
<p>Hint 1: Remember that you can use <code>first</code> and <code>rest</code> on a map too!</p>
<p>Hint 2: There are multiple ways to implement this, but you can consider using <code>concat</code> and <code>repeat</code>.</p>
</section>
</section>
<section class="level3" id="merging-and-sorting">
<h3>Merging and sorting</h3>
<section class="alert alert-success">
<h3>
Exercise 16
</h3>
<p>Write a function <code>seq-merge</code> that takes two (low to high) sorted number sequences and combines them into one sorted sequence. E.g.:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(seq-merge [<span class="dv">4</span>] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">6</span> <span class="dv">7</span>])        <span class="co">;=&gt; (1 2 4 6 7)</span>
(seq-merge [<span class="dv">1</span> <span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>] [<span class="dv">2</span> <span class="dv">2</span> <span class="dv">8</span> <span class="dv">10</span>]) <span class="co">;=&gt; (1 2 2 5 7 8 9 10)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 17
</h3>
<p>Write the function <code>merge-sort</code> that implements <a href="http://en.wikipedia.org/wiki/Merge_sort">merge sort</a>. The idea of merge sort is to divide the input into subsequences, sort them, and use the <code>seq-merge</code> function defined above to merge the sorted subsequences. If two subsequences are in sorted order, merging them will result in a sorted sequence. If the subsequences are divided recursively into small enough pieces that they can be sorted with other means (e.g. trivially when the subsequences are one element long), the <code>merge</code> step then merges all the subsequences into sorted order when the recursion returns from each subsequence.</p>
<p>Conceptually: - If the sequence is 0 or 1 elements long, it is already sorted. - Otherwise, divide the sequence into two subsequences. - Sort each subsequence recursively. - Merge the two subsequences back into one sorted sequence.</p>
<p>This conceptual code recurses until the subsequences are very short. An alternative implementation might choose a threshold of 100 elements and sort sequences below that length with quicksort. The exercise doesn’t require this.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">    (merge-sort [<span class="dv">4</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span>])
<span class="co">;=&gt; (seq-merge (merge-sort (4 2))</span>
<span class="co">;              (merge-sort (3 1)))</span>
<span class="co">;=&gt; (seq-merge (seq-merge (merge-sort (4))</span>
<span class="co">;                         (merge-sort (2)))</span>
<span class="co">;              (seq-merge (merge-sort (3))</span>
<span class="co">;                         (merge-sort (1))))</span>
<span class="co">;=&gt; (seq-merge (seq-merge (4) (2))</span>
<span class="co">;              (seq-merge (3) (1)))</span>
<span class="co">;=&gt; (seq-merge (2 4) (1 3))</span>
<span class="co">;=&gt; (1 2 3 4)</span></code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(merge-sort [])                 <span class="co">;=&gt; ()</span>
(merge-sort [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])            <span class="co">;=&gt; (1 2 3)</span>
(merge-sort [<span class="dv">5</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">17</span> <span class="dv">2</span> <span class="dv">100</span> <span class="dv">1</span>]) <span class="co">;=&gt; (1 2 3 4 5 17 100)</span></code></pre>
<p>You can use the <code>halve</code> function from Collections exercise C2.</p>
</section>
</section>
</section>
<section class="level2" id="bonus-problems">
<h2>Bonus problems</h2>
<section class="alert alert-success">
<h3>
Exercise 18
</h3>
<p>Given a sequence, return all permutations of that sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(permutations [])      <span class="co">;=&gt; ()</span>
(permutations [<span class="dv">1</span> <span class="dv">5</span> <span class="dv">3</span>]) <span class="co">;=&gt; ((1 5 3) (5 1 3) (5 3 1) (1 3 5) (3 1 5) (3 5 1))</span></code></pre>
<p>Order of permutations doesn’t matter.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 19
</h3>
<p>Given a sequence, return the powerset of that sequence.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(powerset [])      <span class="co">;=&gt; (())</span>
(powerset [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>]) <span class="co">;=&gt; (() (4) (2) (2 4) (1) (1 4) (1 2) (1 2 4))</span></code></pre>
<p>Order of subsequences doesn’t matter.</p>
</section>
</section>
<footer>
    <p>
        &copy; <a href="http://iloveponies.github.com">iloveponies</a>.

        <span style="float: right">
            <a href="mailto:ilmari.vacklin@gmail.com">questions?</a>
        </span>
    </p>
</footer>
</div>
</div>
</div>
</body>
</html>
