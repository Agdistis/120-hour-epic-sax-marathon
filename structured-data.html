<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="120 hour epic">
  <title>Structured data</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
</head>
<body>
<div class="container-fluid">
<div class="row-fluid">
<div class="span12"><div class="top-nav"><a href="index.html">← index</a></div>
<header>
<h1 class="title">Structured data</h1>
<h2 class="author">120 hour epic</h2>
<h3 class="date">sax marathon</h3>
</header>
<section class="level2" id="synopsis">
<h2>Synopsis</h2>
<p>In which we learn to work with structured data.</p>
<ul>
<li>Names</li>
<li>Sequences</li>
<li>Vectors</li>
<li>Maps</li>
</ul>
<section class="alert alert-info">
<h3>
Hint
</h3>
<p>The following web pages are good references to Clojure builtins and data structures:</p>
<ul>
<li><a href="http://clojuredocs.org">ClojureDocs</a></li>
<li><a href="http://clojure.org/cheatsheet">Clojure cheatsheet</a></li>
</ul>
</section>
</section>
<section class="level2" id="get-the-project">
<h2>Get the project</h2>
<p>Clone the project for this chapter:</p>
<pre><code>git clone https://github.com/iloveponies/structured-data.git</code></pre>
</section>
<section class="level2" id="let-there-be-names">
<h2>Let there be names</h2>
<p>We often want to give a piece of data name, either because the act of naming gives clarity to the code, or because we want to refer to the data many times. As we have seen, package global names are declared with <code>def</code>. A function or value that is needed only inside one function can be given a <em>local name</em> with <code>let</code>.</p>
<p>As an example, let’s define a function for calculating the length of a triangle’s hypotenuse, given the length of its two legs:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> hypotenuse </span>[x y]
  (<span class="kw">let</span> [xx (<span class="kw">*</span> x x)
        yy (<span class="kw">*</span> y y)]
    (Math/sqrt (<span class="kw">+</span> xx yy))))</code></pre>
<p>Here we give the expressions <code>(* x x)</code> and <code>(* y y)</code> the local names <code>xx</code> and <code>yy</code>, respectively. They are visible only inside <code>hypotenuse</code>.</p>
<p><code>let</code> introduces one or more names and a scope for them:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [name1 value1
      name2 value2
      ...]
  (expression1)
  (expression2)
  ...)</code></pre>
<p>The names introduced by <code>let</code> are visible in all the expressions after them, under <code>let</code>. A name is not visible to code outside the body of the <code>let</code> it is defined in.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">let</span> [x <span class="dv">42</span>]
         (<span class="kw">+</span> x x))
<span class="co">;=&gt; 84</span>
user=&gt; x
CompilerException java.lang.RuntimeException:
Unable to <span class="kw">resolve</span> symbol: x in this context, compiling<span class="kw">:(NO_SOURCE_PATH:0)</span> </code></pre>
<p>Note the indentation in <code>let</code>: the names inside the brackets are all aligned together, and the expressions are indented with two spaces.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [x <span class="dv">42</span>]
  (indented x))</code></pre>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>The following function does a thing:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> do-a-thing </span>[x]
  (Math/pow (<span class="kw">+</span> x x) (<span class="kw">+</span> x x)))</code></pre>
<p>Change the function <code>do-a-thing</code> so that it uses <code>let</code> to give a name to the common expression <code>(+ x x)</code> in its body.</p>
</section>
<p>The names declared in a <code>let</code> expression can refer to previous names in the same expression:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [a <span class="dv">42</span>
      b (<span class="kw">+</span> a <span class="dv">8</span>)]
  [a b])
<span class="co">;=&gt; [42 50]</span></code></pre>
<p>In the example above, <code>b</code> can refer to <code>a</code> because <code>a</code> is declared before it. On the other hand, <code>a</code> can not refer to b:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [a (<span class="kw">+</span> b <span class="dv">42</span>)
      b <span class="dv">8</span>]
  [a b])
<span class="co">; CompilerException java.lang.RuntimeException: Unable to resolve symbol:</span>
<span class="co">; b in this context, compiling:(NO_SOURCE_PATH:1) </span></code></pre>
</section>
<section class="level2" id="simple-values">
<h2>Simple values</h2>
<p>Now that we know how to give names to values, let’s look at what kind of values Clojure supports.</p>
<p>Scalar values are the regular, singular simple values like <code>42</code>, <code>&quot;foo&quot;</code> or <code>true</code>. The following table describes some of them.</p>
<table>
<col style="width: 20%" /><col style="width: 26%" /><col style="width: 52%" /><thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Examples</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Numbers</td>
<td style="text-align: left;"><code>42</code>, <code>3/2</code>, <code>2.1</code></td>
<td style="text-align: left;">Numbers include integers, fractions, and floats.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Strings</td>
<td style="text-align: left;"><code>&quot;foo&quot;</code></td>
<td style="text-align: left;">Text values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Characters</td>
<td style="text-align: left;"><code>\x</code>, <code>\y</code>, <code>\√</code></td>
<td style="text-align: left;">A single characer is written with a preceding <code>\</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Keywords</td>
<td style="text-align: left;"><code>:foo</code>, <code>:?</code></td>
<td style="text-align: left;">Values often used as map keys.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Booleans</td>
<td style="text-align: left;"><code>true</code>, <code>false</code></td>
<td style="text-align: left;">Boolean values.</td>
</tr>
</tbody>
</table>
</section>
<section class="level2" id="vectors">
<h2>Vectors</h2>
<p>Collections are the other kind of data structure, in addition to scalars, that are crucial to programming. Clojure has support for a rich set of collection data structures. We’ll go over the most important structures in this chapter.</p>
<p>A <em>vector</em> is a collection that can be indexed with integers, like an array in other languages. It can contain values of different types.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]                 <span class="co">;=&gt; [1 2 3]</span>
[<span class="kw">:foo</span> <span class="dv">42</span> <span class="st">&quot;bar&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">3</span>)] <span class="co">;=&gt; [:foo 42 &quot;bar&quot; 5]</span></code></pre>
<p>A vector is written with surrounding brackets, <code>[]</code>, and the elements are written inside, separated by whitespace and optionally commas (<code>,</code>).</p>
<p>Vectors are indexed with the <code>get</code> function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">1</span>)  <span class="co">;=&gt; &quot;b&quot;</span>
(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">15</span>) <span class="co">;=&gt; nil</span>
(<span class="kw">get</span> [<span class="st">&quot;x&quot;</span>] <span class="dv">0</span>)          <span class="co">;=&gt; &quot;x&quot;</span></code></pre>
<p>Trying to index a vector beyond its size does <em>not</em> throw an exception. The special value <code>nil</code> is returned, instead.</p>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(spiff v)</code> that takes a vector and returns the sum of the first and third elements of the vector. What happens when you pass in a vector that is too short?</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(spiff [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])       <span class="co">;=&gt; 4</span>
(spiff [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]) <span class="co">;=&gt; 4</span>
(spiff [<span class="dv">1</span> <span class="dv">2</span>])         <span class="co">;=&gt; ?</span>
(spiff [])            <span class="co">;=&gt; ?</span></code></pre>
</section>
<section class="level3" id="basic-vector-operations">
<h3>Basic vector operations</h3>
<p>Vectors are immutable: once you have a vector, <em>you can not change it</em>. You can, however, easily create new vectors based on a vector:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] <span class="dv">4</span>)          <span class="co">;=&gt; [1 2 3 4]</span>
(<span class="kw">assoc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>) <span class="co">;=&gt; [1 2 &quot;foo&quot; 4]</span></code></pre>
<p><code>conj</code> adds a value to a collection. Its behaviour depends on the type of collection: with vectors, it adds the value to the end of the vector. To be exact, <code>conj</code> does <em>not</em> change the given vector. Instead, it returns a new vector, based on the given vector, with the new element appended to this new vector.</p>
<p><code>assoc</code> associates a new value for the given key in the collection. A vector’s indexes are its keys. Above, we create a new vector based on the previous one, with <code>&quot;foo&quot;</code> at index <code>2</code>. The original vector doesn’t change in either of these operations:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [original [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]
      new      (<span class="kw">assoc</span> original <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>)]
  original)
<span class="co">;=&gt; [1 2 3 4]</span></code></pre>
<p>Finally, <code>count</code> returns the size of a collection:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; 4</span>
(<span class="kw">count</span> [])        <span class="co">;=&gt; 0</span></code></pre>
</section>
<section class="level3" id="vectors-a-postmodern-deconstruction">
<h3>Vectors: A Postmodern Deconstruction</h3>
<p>Another way of extracting values from a vector is by <em>destructuring</em> it:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [[x y z] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]]
  (<span class="kw">str</span> x y z))
<span class="co">;=&gt; &quot;123&quot;</span></code></pre>
<p>Here, instead of giving a name to the vector <code>[1 2 3 4 5 6]</code>, we indicate with the brackets in <code>[x y z]</code> that we want to destructure the vector instead. Inside the brackets, we give names to the first three elements of the vector. <code>x</code> will be given the value of the first element, <code>1</code>; <code>b</code> will be <code>2</code> and <code>c</code> will be <code>3</code>. The concatenation of these values that <code>str</code> returns is <code>&quot;123&quot;</code>.</p>
<p>You can destructure function parameters directly. For an example, take the following function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum-pairs </span>[first-pair second-pair]
  [(<span class="kw">+</span> (<span class="kw">first</span>  first-pair) (<span class="kw">first</span>  second-pair))
   (<span class="kw">+</span> (<span class="kw">second</span> first-pair) (<span class="kw">second</span> second-pair))])</code></pre>
<p>The function takes two vectors and sums their first pairwise elements:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(sum-pairs [<span class="dv">42</span> <span class="dv">5</span>]   [-<span class="dv">42</span> -<span class="dv">5</span>])   <span class="co">;=&gt; [0 0]</span>
(sum-pairs [<span class="dv">64</span> <span class="dv">256</span>] [-<span class="dv">51</span> -<span class="dv">219</span>]) <span class="co">;=&gt; [13 37]</span></code></pre>
<p><code>sum-pair</code> is not very pretty to look at. We can spiff it up by taking out the elements of its parameter vectors by destructuring them:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum-pairs </span>[[x1 y1] [x2 y2]]
  [(<span class="kw">+</span> x1 x2) (<span class="kw">+</span> y1 y2)])</code></pre>
<p><code>sum-pairs</code> still takes two parameter vectors, but now it does not give names to its parameters. Instead, it gives names to their first two elements by destructuring the parameters. We could have also destructured the parameters with a <code>let</code>.</p>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Rewrite our earlier function <code>spiff</code> by destructuring its parameters. Call this new function <code>spiff-destructuring</code>.</p>
</section>
</section>
</section>
<section class="level2" id="maps">
<h2>Maps</h2>
<p>Where a vector associates integers to values, a <em>map</em> is not restricted to integer keys. You can use any kind of value as a key. A map is written with curly brackets, <code>{}</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">{<span class="st">&quot;foo&quot;</span> <span class="dv">42</span>, <span class="st">&quot;bar&quot;</span> <span class="dv">666</span>}
{<span class="st">&quot;mehmeh&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">5</span>)
 <span class="st">&quot;rupatipor&quot;</span> <span class="st">&quot;ropopo&quot;</span>}</code></pre>
<p>A map is indexed with the <code>get</code> function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [ages {<span class="st">&quot;Juhana&quot;</span> <span class="dv">3</span>
            <span class="st">&quot;Ilmari&quot;</span> <span class="dv">42</span>
            <span class="st">&quot;King of All Cosmos&quot;</span> -<span class="dv">6</span>}]
  (<span class="kw">get</span> ages <span class="st">&quot;King of All Cosmos&quot;</span>))
<span class="co">;=&gt; -6</span></code></pre>
<p>In idiomatic Clojure programs, the keys of a map are often <em>keywords</em>. Keywords are a convenient way of naming keys for values in associative collections such as maps. They are written with a preceding <code>:</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> book </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
           <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">get</span> book <span class="kw">:title)</span> <span class="co">;=&gt; &quot;The City and the City&quot;</span></code></pre>
<p>Keywords are even more convenient than this. They work as functions that access collections:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">:title</span> book) <span class="co">;=&gt; &quot;The City and the City&quot;</span></code></pre>
<p>When used as a function and given a collection, a keyword looks itself up in the collection and returns the value associated with it.</p>
<p><code>assoc</code> works with a map:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">assoc</span> book <span class="kw">:awards</span> [<span class="st">&quot;Hugo&quot;</span>, <span class="st">&quot;World Fantasy Award&quot;</span>, <span class="st">&quot;Arthur C. Clarke Award&quot;</span>, <span class="st">&quot;British Science Fiction Award&quot;</span>])
<span class="co">;=&gt; {:author {:birth-year 1972, :name &quot;China Miéville&quot;}</span>
<span class="co">;    :awards [&quot;Hugo&quot; &quot;World Fantasy Award&quot; &quot;Arthur C. Clarke Award&quot; &quot;British Science Fiction Award&quot;]</span>
<span class="co">;    :title &quot;The City and the City&quot;}</span></code></pre>
<p>The keys and values of a map can be of any data type, and one map can contain any number of different data types as both keys and values.</p>
<p><code>count</code> returns the size of a map, which is determined by how many keys it has:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> {<span class="kw">:a</span> <span class="dv">42</span>, <span class="kw">:b</span> <span class="st">&quot;foo&quot;</span>, <span class="kw">:c</span> <span class="dv">1337</span>}) <span class="co">;=&gt; 3</span>
(<span class="kw">count</span> {})                         <span class="co">;=&gt; 0</span></code></pre>
<p>Let’s define a couple of books like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
             <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})</code></pre>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(alive? author)</code> which takes an author map and returns <code>true</code> if the <code>author</code> is alive, otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(alive? (<span class="kw">:author</span> cities))    <span class="co">;=&gt; true</span>
(alive? (<span class="kw">:author</span> wild-seed)) <span class="co">;=&gt; false</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(title-length book)</code> that counts the length of the book’s title. Use <code>let</code> to extract the title.</p>
<p>You can use <code>count</code> to find out the length of a string:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> <span class="st">&quot;foo&quot;</span>) <span class="co">;=&gt; 3</span></code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(title-length cities)    <span class="co">;=&gt; 21</span>
(title-length wild-seed) <span class="co">;=&gt; 9</span></code></pre>
</section>
</section>
<section class="level2" id="serial-grave-digging">
<h2>Serial grave digging</h2>
<p>We know how to extract information from a single book or author. However, we often want to extract information from a collection of items. As an example, given a collection of books, we want the names of all the authors:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>,
                  <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>,
                           <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown])

(all-author-names books) <span class="co">;=&gt; #{&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;}</span></code></pre>
<p>How should we implement <code>all-author-names</code>?</p>
<p>We’ll give the implementation now, and introduce the new concepts used one by one. The implementation looks like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>Now there’s a lot of new stuff there, so we’ll take a detour to learn them before continuing with our book library.</p>
<section class="level3" id="anonymous-functions">
<h3>Anonymous functions</h3>
<p><code>fn</code> defines an anonymous function.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">fn</span> [x] (<span class="kw">*</span> x x))
#&lt;user$eval1189$fn__1190 user$eval1189$fn__1190<span class="kw">@5627f221&gt;</span></code></pre>
<p>Okay, se we get a function. This can be called like any other function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; ((<span class="kw">fn</span> [x] (<span class="kw">*</span> x x)) <span class="dv">4</span>)
<span class="dv">16</span></code></pre>
<p>Using it like this is pretty awkward, usually we want our functions to have a name instead.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> square</span>
  (<span class="kw">fn</span> [x] (<span class="kw">*</span> x x)))
(square <span class="dv">4</span>) <span class="co">;=&gt; 16</span></code></pre>
<p>This is pretty much how defn works, though it does more, like handles doc-strings that you can find with <code>doc</code>.</p>
<p>Anonymous functions are useful when you want short helper functions. You can give them names with a <code>let</code> and they will only be visible in that context.</p>
<p>In the function <code>all-author-names</code>, that we can’t fully understand yet, we wanted a helper function that the name of the author of a book:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>So we want that <code>author-name</code> works like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})

(author-name wild-seed) <span class="co">;=&gt; &quot;Octavia E. Butler&quot;</span></code></pre>
<p>And that’s what the above definition does. But since it is defined inside <code>all-author-names</code>, it is only visible inside that function.</p>
<p>TODO: fn-sormiharjoittelua, tehtävä tai pari, mahollisesti letin kanssa</p>
<p>Theres another elephant in the living room, so let’s look at this <code>map</code> function next.</p>
</section>
<section class="level3" id="sequences">
<h3>Sequences</h3>
<p>Before talking about <code>map</code>, we need to introduce a concept: the <em>sequence</em>. Many of Clojure’s functions that operate on vectors and other collections actually operate on sequences. The <code>(seq collection)</code> function returns a sequence constructed from a collection, such as a vector or a map.</p>
<p>Sequences have the following operations:</p>
<ul>
<li><p><code>(first sequence)</code> returns the first element of the sequence.</p></li>
<li><p><code>(rest sequence)</code> returns the sequence without its first element.</p></li>
<li><p><code>(cons item sequence)</code> returns a new sequence where <code>item</code> is the first element and <code>sequence</code> is the rest.</p></li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])          <span class="co">;=&gt; (1 2 3)</span>
(<span class="kw">seq</span> {<span class="kw">:a</span> <span class="dv">42</span> <span class="kw">:b</span> <span class="st">&quot;foo&quot;</span> <span class="kw">:c</span> [<span class="st">&quot;ur&quot;</span> <span class="st">&quot;dad&quot;</span>]})
                       <span class="co">;=&gt; ([:a 42] [:c [&quot;ur&quot; &quot;dad&quot;]] [:b &quot;foo&quot;])</span>
(<span class="kw">first</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))  <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))    <span class="co">;=&gt; (2 3)</span>
(<span class="kw">cons</span> <span class="dv">0</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])) <span class="co">;=&gt; (0 1 2 3)</span></code></pre>
<p>Here you can see the printed form of sequences, the elements inside <code>(</code> and <code>)</code>. This has the consequence that copying <code>(1 2 3)</code> back to the REPL tries to call <code>1</code> as a function. The result is that you can not use the printed form of a sequence as a value like you could with vectors and maps.</p>
<p>Actually, the sequence functions call <code>seq</code> on their collection parameters themselves, so we can just write the above examples like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">first</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])  <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; (2 3)</span>
(<span class="kw">cons</span> <span class="dv">0</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; (0 1 2 3)</span></code></pre>
</section>
<section class="level3" id="the-map-function">
<h3>The map function</h3>
<p><code>(map function collection)</code> takes two parameters, a function and a sequencable collection. It calls the function on each element of the sequence and returns a sequence of the return values.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> munge </span>[x]
  (<span class="kw">+</span> x <span class="dv">42</span>))

(<span class="kw">map</span> munge [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])
<span class="co">;=&gt; ((munge 1) (munge 2) (munge 3) (munge 4)) ; [note below]</span>
<span class="co">;=&gt; ( 43        44        45        46)</span></code></pre>
<p><em>Note:</em> You can’t paste the result line (or the middle one) to the REPL, as it is the printed form of a sequence.</p>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(element-lengths collection)</code> that returns the lengths of every item in <code>collection</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(element-lengths [<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;quux&quot;</span>])  <span class="co">;=&gt; (3 3 0 4)</span>
(element-lengths [<span class="st">&quot;x&quot;</span> [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c]</span> {<span class="kw">:y</span> <span class="dv">42</span>}]) <span class="co">;=&gt; (1 3 1)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Use <code>map</code> to write the function <code>(second-elements collection)</code> that takes a vector of vectors and returns a sequence of the second elements.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(second-elements [[<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">3</span> <span class="dv">4</span>]]) <span class="co">;=&gt; (2 3 4)</span>
(second-elements [[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] [<span class="dv">1</span>] [<span class="st">&quot;a&quot;</span> <span class="st">&quot;s&quot;</span> <span class="st">&quot;d&quot;</span> <span class="st">&quot;f&quot;</span>]])
<span class="co">;=&gt; (2 nil &quot;s&quot;)</span></code></pre>
<p>Remember that you can use <code>get</code> to index a vector.</p>
<p>Use <code>fn</code> and <code>let</code> to create a helper function and use it with <code>map</code>.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(titles books)</code> that takes a collection of books and returns their titles.</p>
<p>Using our earlier examples:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
             <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>,
                  <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>,
                           <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown])</code></pre>
<p><code>titles</code> should work like this:</p>
<pre><code>(titles [cities]) ;=&gt; (&quot;The City and the City&quot; )
(titles books)    ;=&gt; (&quot;The City and the City&quot; &quot;Wild Seed&quot; &quot;Embassytown&quot;)</code></pre>
<p>Remember that you can use <code>:keywords</code> as functions.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">:name</span> {<span class="kw">:name</span> <span class="st">&quot;MEEEE&quot;</span>, <span class="kw">:secret</span> <span class="st">&quot;Awesome&quot;</span>}) <span class="co">;=&gt;  &quot;MEEEE&quot;</span></code></pre>
</section>
<p>We can now almost undestand the definition of <code>all-author-names</code>. Remember that our implementation looked like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>The final piece is the <code>set</code> function, which we haven’t introduced yet. However, let’s try the function without <code>set</code>, first.</p>
<p>We had these example books:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
             <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>,
                  <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>,
                           <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown])</code></pre>
<p>And if we define <code>all-author-names</code> without <code>set</code>, we have:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">map</span> author-name books)))</code></pre>
<p>Here is how it works:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(all-author-names books) <span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot; &quot;China Miéville&quot;)</span></code></pre>
<p>We had two books by China Miéville, so his name is in the resulting sequence twice. But when we want to see the authors, we are usually not interested in duplicates. So lets turn the sequence into a data structure that supports this.</p>
</section>
<section class="level3" id="set">
<h3>Set</h3>
<p>Our last major data structure is set. It is an unordered collection of items without duplicates.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">set</span> [<span class="st">&quot;^^&quot;</span> <span class="st">&quot;^^&quot;</span> <span class="st">&quot;^__*__^&quot;</span>]) <span class="co">;=&gt; #{&quot;^__*__^&quot; &quot;^^&quot;}</span>
(<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">;=&gt; #{1 2 3}</span></code></pre>
<p>The textual form of sets is <code>#{an-elem another-elem ...}</code> and you can convert another collection into a set with the function <code>set</code>.</p>
<p>Sets have three basic operations:</p>
<p>You can check whether a set contains an element with the function <code>contains?</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> games </span>#{<span class="st">&quot;Portal&quot;</span>, <span class="st">&quot;Planescape: Torment&quot;</span>,
             <span class="st">&quot;Machinarium&quot;</span>, <span class="st">&quot;Alpha Protocol&quot;</span>})

(<span class="kw">contains?</span> games <span class="st">&quot;Portal&quot;</span>) <span class="co">;=&gt; true</span>
(<span class="kw">contains?</span> games <span class="st">&quot;RAGE&quot;</span>)   <span class="co">;=&gt; false</span>
(<span class="kw">contains?</span> games <span class="dv">42</span>)       <span class="co">;=&gt; false</span></code></pre>
<p><code>(conj set elem)</code> adds elem to <code>set</code> if it does not already have <code>elem</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:EEEEE)</span> <span class="co">;=&gt; #{:a :c :b :EEEEE}</span>
(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:a)</span>     <span class="co">;=&gt; #{:a :c :b}</span>
(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:d</span> <span class="kw">:e)</span>  <span class="co">;=&gt; #{:a :c :b :d :e}</span></code></pre>
<p>Finally, <code>(disj set elem)</code> removes <code>elem</code> from <code>set</code> if it contains <code>elem</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:c)</span> <span class="co">;=&gt; #{:a :b}</span>
(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:EEEEE)</span> <span class="co">;=&gt; #{:a :c :b}</span>
(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:c</span> <span class="kw">:a)</span> <span class="co">;=&gt; #{:b}</span></code></pre>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(toggle a-set elem)</code> that removes <code>elem</code> from <code>a-set</code> if it exists in the set, and adds it to the set otherwise.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(toggle #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:d)</span> <span class="co">;=&gt; #{:a :c :b :d}</span>
(toggle #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:a)</span> <span class="co">;=&gt; #{:c :b}</span></code></pre>
</section>
<p>Now we can understand the whole implementation of <code>all-author-names</code>. We use - <code>fn</code> to introduce a helper function, - keywords to index the books, - <code>let</code> to give a name to our helper function, - <code>map</code> to apply the helper function to all the given books, and - construct a set with the <code>set</code> function to get rid of duplicates.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>Calling our function returns the desired set:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(all-author-names books) <span class="co">;=&gt; #{&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;}</span></code></pre>
</section>
</section>
<section class="level2" id="filtering-sequences">
<h2>Filtering sequences</h2>
<p>Another common function besides <code>map</code> is <code>filter</code>. It is used to select some elements of a sequence and disregard the rest:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">filter</span> <span class="kw">pos?</span> [-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>]) <span class="co">;=&gt; (6 7 3)</span>
(<span class="kw">filter</span> (<span class="kw">fn</span> [x] (<span class="kw">&gt;</span> (<span class="kw">count</span> x) <span class="dv">2</span>)) [<span class="st">&quot;ff&quot;</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;ffffff&quot;</span> <span class="st">&quot;fff&quot;</span>])
<span class="co">;=&gt; (&quot;ffffff&quot; &quot;fff&quot;)</span></code></pre>
<p><code>(filter predicate collection)</code> takes two parameters, a function and a sequencable collection. It calls the function on each element of the sequence and returns a sequence of the values from the collection for which the function returned a truthy value. In the above example the values <code>(6 7 3)</code> were selected because for them <code>pos?</code> returned true; for the others it returned false, a falsey value, and they were filtered out.</p>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Write the function <code>(books-by-author author books)</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(books-by-author <span class="st">&quot;China Miéville&quot;</span> books) <span class="co">;=&gt; (cities embassytown)</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Implement <code>(book-titles-by-author author books)</code>, which returns the book titles of the books by the given author.</p>
<p>Use <code>books-by-author</code> as a helper function.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Implement <code>(authors books)</code>, which returns all the authors in a set.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Implement <code>(author-names authors)</code>, which returns all the author names in a set.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise
</h3>
<p>Using the two previous functions, implement <code>(books-&gt;author-names books)</code>, which returns all the books’ authors’ names in a set.</p>
</section>
<section class="level3" id="keeping-your-vectors">
<h3>Keeping your vectors</h3>
<p><code>map</code> and <code>filter</code> always return sequences, regardless of the collection type given as a parameter. Sometimes, however, you want the result to be a vector. For an example, you may want to index the vector afterwards. In this situation, you can use <code>mapv</code> and <code>filterv</code>, which are variants of <code>map</code> and <code>filter</code> that always return vectors.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(mapv ... [...])    <span class="co">;=&gt; [...]</span>
(filterv <span class="kw">pos?</span> [-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>])  <span class="co">;=&gt; [6 7 3]</span>
(filterv <span class="kw">pos?</span> #{-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>}) <span class="co">;=&gt; [3 6 7]</span>
(mapv ... #{...})   <span class="co">;=&gt; [...]</span></code></pre>
</section>
</section>
<footer>
    <p>
        &copy; <a href="http://iloveponies.github.com">iloveponies</a>.

        <span style="float: right">
            <a href="mailto:ilmari.vacklin@gmail.com">questions?</a>
        </span>
    </p>
</footer>
</div>
</div>
</div>
</body>
</html>
