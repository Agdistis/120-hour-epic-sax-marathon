<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="120 hour epic">
  <title>Structured data</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
</head>
<body>

<header>
<h1 class="title">Structured data</h1>
<h2 class="author">120 hour epic</h2>
<h3 class="date">sax marathon</h3>
</header>
<section class="level2" id="synopsis">
<h2>Synopsis</h2>
<p>In which we learn to work with structured data.</p>
<ul>
<li>Names</li>
<li>Sequences</li>
<li>Vectors</li>
<li>Maps</li>
</ul>
</section>
<section class="level2" id="let-there-be-names">
<h2>Let there be names</h2>
<p>We often want to give a piece of data name, either because the act of naming gives clarity to the code, or because we want to refer to the data many times. As we have seen, global names are declared with <code>def</code>. Local names, on the other hand, are declared with <code>let</code>.</p>
<p>As an example, let's define a function for calculating the length of a triangle's hypotenuse, given the length of its two legs:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> hypotenuse </span>[x y]
  (<span class="kw">let</span> [xx (<span class="kw">*</span> x x)
        yy (<span class="kw">*</span> y y)]
    (Math/sqrt (<span class="kw">+</span> xx yy))))</code></pre>
<p><code>let</code> introduces one or more names and a scope for them:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [name1 value1
      name2 value2
      ...]
  (expression1)
  (expression2)
  ...)</code></pre>
<p>The names introduced by <code>let</code> are visible in all the expressions after them, under <code>let</code>. A name is not visible to code outside the body of the <code>let</code> it is defined in.</p>
<p>TODO: Example</p>
<p><section class="alert alert-success"> The following function does a thing:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> do-a-thing </span>[x]
  (Math/pow (<span class="kw">+</span> x x) (<span class="kw">+</span> x x)))</code></pre>
<p>Change the function <code>do-a-thing</code> so that it uses <code>let</code> to give a name to the common expression <code>(+ x x)</code> in its body.</p>
</section>
<p>TODO: let is let*</p>
</section>
<section class="level2" id="simple-values">
<h2>Simple values</h2>
<p>Now that we know how to give names to values, let's look at what kind of values Clojure supports.</p>
<p>Scalar values are the regular, singular simple values like <code>42</code>, <code>&quot;foo&quot;</code> or <code>true</code>. The following table describes some of them.</p>
<table>
<col style="width: 20%" /><col style="width: 26%" /><col style="width: 52%" /><thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Examples</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Numbers</td>
<td style="text-align: left;"><code>42</code>, <code>3/2</code>, <code>2.1</code></td>
<td style="text-align: left;">Numbers include integers, fractions, and floats.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Strings</td>
<td style="text-align: left;">&quot;foo&quot;</td>
<td style="text-align: left;">Foo.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Characters</td>
<td style="text-align: left;"><code>\x</code>, <code>\y</code>, <code>\âˆš</code></td>
<td style="text-align: left;">A single characer is written with a preceding <code>\</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Keywords</td>
<td style="text-align: left;"><code>:foo</code>, <code>:?</code></td>
<td style="text-align: left;">How do you describe keywords?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Booleans</td>
<td style="text-align: left;"><code>true</code>, <code>false</code></td>
<td style="text-align: left;">Boolean values.</td>
</tr>
</tbody>
</table>
</section>
<section class="level2" id="vectors">
<h2>Vectors</h2>
<p>Clojure has support for a rich set of collections.</p>
<p>A <em>vector</em> is a collection that can be indexed with integers, like an array in other languages. It can contain values of different types.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]                 <span class="co">;=&gt; [1 2 3]</span>
[<span class="kw">:foo</span> <span class="dv">42</span> <span class="st">&quot;bar&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">3</span>)] <span class="co">;=&gt; [:foo 42 &quot;bar&quot; 5]</span></code></pre>
<p>You can index a vector with <code>get</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">1</span>)  <span class="co">;=&gt; &quot;b&quot;</span>
(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">15</span>) <span class="co">;=&gt; nil</span>
(<span class="kw">get</span> [<span class="st">&quot;x&quot;</span>] <span class="dv">0</span>)          <span class="co">;=&gt; &quot;x&quot;</span></code></pre>
<p><section class="alert alert-success"> Write the function <code>(spiff v)</code> that takes a vector and returns the sum of the first and third elements of the vector. What happens when you pass in a vector that is too short?</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(spiff  [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])       <span class="co">;=&gt; 4</span>
(spiff  [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]) <span class="co">;=&gt; 4</span>
(spiff  [<span class="dv">1</span> <span class="dv">2</span>])         <span class="co">;=&gt; ?</span>
(spiff  [])            <span class="co">;=&gt; ?</span></code></pre>
</section>
<p>Vectors are immutable: once you have a vector, <em>you can not change it</em>. You can, however, easily create new vectors based on a vector:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] <span class="dv">4</span>)          <span class="co">;=&gt; [1 2 3 4]</span>
(<span class="kw">assoc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>) <span class="co">;=&gt; [1 2 &quot;foo&quot; 4]</span></code></pre>
<p><code>conj</code> adds a value to a collection. Its behaviour depends on the type of collection: with vectors, it adds the value to the end of the vector.</p>
<p><code>assoc</code> associates a new value for the given key in the collection. A vector's indexes are its keys. Above, we create a new vector based on the previous one, with &quot;foo&quot; at index 2. The original vector doesn't change in either of these operations.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [original [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]
      new      (<span class="kw">assoc</span> original <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>)]
  original)
<span class="co">;=&gt; [1 2 3 4]</span></code></pre>
<p><code>count</code> returns the size of a collection:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; 4</span>
(<span class="kw">count</span> [])        <span class="co">;=&gt; 0</span></code></pre>
</section>
<section class="level2" id="postmodernism">
<h2>Postmodernism</h2>
<p>Another way of extracting values from a vector is by <em>destructuring</em> it:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [[x y z] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]]
  (<span class="kw">str</span> x y z))
<span class="co">;=&gt; &quot;123&quot;</span></code></pre>
<p>Here, instead of giving a name to the vector <code>[1 2 3 4 5 6]</code>, we indicate with the brackets in <code>[x y z]</code> that we want to destructure the vector instead. Inside the brackets, we give names to the first three elements of the vector.</p>
<p><code>let</code> is not the only context destructuring works in. You can also destructure function parameters directly. For an example, take the following function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum-pairs </span>[first-pair second-pair]
  [(<span class="kw">+</span> (<span class="kw">first</span>  first-pair) (<span class="kw">first</span>  second-pair))
   (<span class="kw">+</span> (<span class="kw">second</span> first-pair) (<span class="kw">second</span> second-pair))])</code></pre>
<p>The function takes two vectors and sums their first pairwise elements:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(sum-pairs [<span class="dv">42</span> <span class="dv">5</span>] [-<span class="dv">42</span> -<span class="dv">5</span>])     <span class="co">;=&gt; [0 0]</span>
(sum-pairs [<span class="dv">64</span> <span class="dv">256</span>] [-<span class="dv">51</span> -<span class="dv">219</span>]) <span class="co">;=&gt; [13 37]</span></code></pre>
<p><code>sum-pair</code> is not very pretty to look at. We can spiff it up by taking out the elements of its parameter vectors by destructuring them:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum-pairs </span>[[x1 y1] [x2 y2]]
  [(<span class="kw">+</span> x1 x2) (<span class="kw">+</span> y1 y2)])</code></pre>
<p><code>sum-pairs</code> still takes two parameter vectors, but now it does not give names to its parameters. Instead, it gives names to their first two elements by destructuring the parameters.</p>
<p>TODO: <code>&amp;</code>, nested destructuring, <code>:as</code>, <code>(let [[x] [1 2]])</code></p>
<p><section class="alert alert-success"> Rewrite our earlier function <code>spiff</code> by destructuring its parameters.</p>
</section>
</section>
<section class="level2" id="maps">
<h2>Maps</h2>
<p>Where a vector associates integers to values, a <em>map</em> is not restricted to integer keys. You can use any kind of value as a key. A map is written with curly brackets, <code>{}</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">{<span class="st">&quot;foo&quot;</span> <span class="dv">42</span>, <span class="st">&quot;bar&quot;</span> <span class="dv">666</span>}
{<span class="st">&quot;mehmeh&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">5</span>)
 <span class="st">&quot;rupatipor&quot;</span> <span class="st">&quot;ropopo&quot;</span>}</code></pre>
<p>A map is indexed with the <code>get</code> function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [ages {<span class="st">&quot;Juhana&quot;</span> <span class="dv">3</span>
            <span class="st">&quot;Ilmari&quot;</span> <span class="dv">42</span>
            <span class="st">&quot;King of All Cosmos&quot;</span> -<span class="dv">6</span>}]
  (<span class="kw">get</span> ages <span class="st">&quot;King of All Cosmos&quot;</span>))
<span class="co">;=&gt; -6</span></code></pre>
<p>In idiomatic Clojure programs, the keys of a map are often <em>keywords</em>. Keywords are a convenient way of naming keys for values in associative collections such as maps. They are written with a preceding <code>:</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> book </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
           <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">get</span> book <span class="kw">:title)</span> <span class="co">;=&gt; &quot;The City and the City&quot;</span></code></pre>
<p>Keywords are even more convenient than this. They work as functions that access collections:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">:title</span> book) <span class="co">;=&gt; &quot;The City and the City&quot;</span></code></pre>
<p>When used as a function and given a collection, a keyword looks itself up in the collection and returns the value associated with it.</p>
<p><code>assoc</code> works with a map:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">assoc</span> book <span class="kw">:awards</span> [<span class="st">&quot;Hugo&quot;</span>, <span class="st">&quot;World Fantasy Award&quot;</span>, <span class="st">&quot;Arthur C. Clarke Award&quot;</span>, <span class="st">&quot;British Science Fiction Award&quot;</span>])
<span class="co">;=&gt; {:author {:birth-year 1972, :name &quot;China MiÃ©ville&quot;}</span>
<span class="co">;    :awards [&quot;Hugo&quot; &quot;World Fantasy Award&quot; &quot;Arthur C. Clarke Award&quot; &quot;British Science Fiction Award&quot;]</span>
<span class="co">;    :title &quot;The City and the City&quot;}</span></code></pre>
<p>The keys and values of a map can be of any data type, and one map can contain any number of different data types as both keys and values.</p>
<p><code>count</code> returns the size of a map, which is determined by how many keys it has:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> {<span class="kw">:a</span> <span class="dv">42</span>, <span class="kw">:b</span> <span class="st">&quot;foo&quot;</span>, <span class="kw">:c</span> <span class="dv">1337</span>}) <span class="co">;=&gt; 3</span>
(<span class="kw">count</span> {})                         <span class="co">;=&gt; 0</span></code></pre>
<p>TODO: Talk about destructuring maps at some point.</p>
<p>Let's define a couple of books like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
             <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})</code></pre>
<section class="alert alert-success">
<p>Write the function <code>(alive? author)</code> which takes an author map and returns <code>true</code> if the <code>author</code> is alive, otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(alive? (<span class="kw">:author</span> cities))    <span class="co">;=&gt; true</span>
(alive? (<span class="kw">:author</span> wild-seed)) <span class="co">;=&gt; false</span></code></pre>
</section>
<section class="alert alert-success">
<p>Write the function <code>(title-length book)</code> that counts the length of the book's title. Use <code>let</code> to extract the title.</p>
<p>You can use <code>count</code> to find out the length of a string:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> <span class="st">&quot;foo&quot;</span>) <span class="co">;=&gt; 3</span></code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(title-length cities)    <span class="co">;=&gt; 21</span>
(title-length wild-seed) <span class="co">;=&gt; 9</span></code></pre>
</section>
</section>
<section class="level2" id="serial-grave-digging">
<h2>Serial grave digging</h2>
<p>We know how to extract information from a single book or author. However, we often want to extract information from a collection of items. As an example, given a collection of books, we want the names of all the authors:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>,
                  <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>,
                           <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown])

(all-author-names books) <span class="co">;=&gt; #{&quot;China MiÃ©ville&quot; &quot;Octavia E. Butler&quot;}</span></code></pre>
<p>How should we implement <code>all-author-names</code>?</p>
<p>TODO: Introduce this</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>Now there's a lot of new stuff there, so we'll take a detour to learn them before continuing with our book library.</p>
<section class="level3" id="anonymous-functions">
<h3>Anonymous functions</h3>
<p><code>fn</code> defines an anonymous function.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">fn</span> [x] (<span class="kw">*</span> x x))
#&lt;user$eval1189$fn__1190 user$eval1189$fn__1190<span class="kw">@5627f221&gt;</span></code></pre>
<p>Okay, se we get a function. This can be called like any other function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; ((<span class="kw">fn</span> [x] (<span class="kw">*</span> x x)) <span class="dv">4</span>)
<span class="dv">16</span></code></pre>
<p>Using it like this is pretty awkward, usually we want our functions to have a name instead.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> square</span>
  (<span class="kw">fn</span> [x] (<span class="kw">*</span> x x)))
(square <span class="dv">4</span>) <span class="co">;=&gt; 16</span></code></pre>
<p>This is pretty much how defn works, though it does more, like handles doc-strings that you can find with <code>doc</code>.</p>
<p>Anonymous functions are useful when you want short helper functions. You can give them names with a <code>let</code> and they will only be visible in that context.</p>
<p>In the function <code>all-author-names</code>, that we can't fully understand yet, we wanted a helper function that the name of the author of a book:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>So we want that <code>author-name</code> works like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})

(author-name wild-seed) <span class="co">;=&gt; &quot;Octavia E. Butler&quot;</span></code></pre>
<p>And that's what the above definition does. But since it is defined inside <code>all-author-names</code>, it is only visible inside that function.</p>
<p>TODO: fn-sormiharjoittelua, tehtÃ¤vÃ¤ tai pari, mahollisesti letin kanssa</p>
<p>Theres another elephant in the living room, so let's look at this <code>map</code> function next.</p>
</section>
<section class="level3" id="sequences">
<h3>Sequences</h3>
<p>Before talking about <code>map</code>, we need to introduce a concept: the <em>sequence</em>. Many of Clojure's functions that operate on vectors and other collections actually operate on sequences. The <code>(seq collection)</code> function returns a sequence constructed from a collection, such as a vector or a map.</p>
<p>Sequences have the following operations:</p>
<ul>
<li><p><code>(first sequence)</code> returns the first element of the sequence.</p></li>
<li><p><code>(rest sequence)</code> returns the sequence without its first element.</p></li>
<li><p><code>(cons item sequence)</code> returns a new sequence where <code>item</code> is the first element and <code>sequence</code> is the rest.</p></li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])                          <span class="co">;=&gt; (1 2 3)</span>
(<span class="kw">seq</span> {<span class="kw">:a</span> <span class="dv">42</span> <span class="kw">:b</span> <span class="st">&quot;foo&quot;</span> <span class="kw">:c</span> [<span class="st">&quot;ur&quot;</span> <span class="st">&quot;dad&quot;</span>]})
<span class="co">;=&gt; ([:a 42] [:c [&quot;ur&quot; &quot;dad&quot;]] [:b &quot;foo&quot;])</span>
(<span class="kw">first</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))                  <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))                    <span class="co">;=&gt; (2 3)</span>
(<span class="kw">cons</span> <span class="dv">0</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))                 <span class="co">;=&gt; (0 1 2 3)</span></code></pre>
<p>Here you can see the printed form of sequences, the elements inside <code>(</code> and <code>)</code>. This has the consequence that copying <code>(1 2 3)</code> back to the REPL tries to call <code>1</code> as a function. The result is that you can not use the printed form of a sequence as a value like you could with vectors and maps.</p>
<p>Actually, the sequence functions call <code>seq</code> on their collection parameters themselves, so we can just write the above examples like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">first</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])  <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; (2 3)</span>
(<span class="kw">cons</span> <span class="dv">0</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; (0 1 2 3)</span></code></pre>
<p><section class="alert alert-success"> Something on sequences.</p>
</section>
<p>TODO: sekvenssitehtÃ¤vÃ¤ tÃ¤nne</p>
</section>
<section class="level3" id="the-map-function">
<h3>The map function</h3>
<p><code>(map f coll)</code> takes two parameters, a function and a sequencable collection. It calls the function on each element of the sequence and returns a sequence of the return values.</p>
<p>TODO: lispmap</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> munge </span>[x]
  (<span class="kw">+</span> x <span class="dv">42</span>))

(<span class="kw">map</span> munge [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])
<span class="co">;=&gt; ((munge 1) (munge 2) (munge 3) (munge 4)) ; [note below]</span>
<span class="co">;=&gt; ( 43        44        45        46)</span></code></pre>
<p><aside class="alert alert-error"> You can't paste the result line (or the middle one) to the REPL, as it is the printed form of a sequence.</aside></p>
<p><section class="alert alert-success"> Write the function <code>(element-lengths collection)</code> that returns the lengths of every item in <code>collection</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(element-lengths [<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;quux&quot;</span>])  <span class="co">;=&gt; (3 3 0 4)</span>
(element-lengths [<span class="st">&quot;x&quot;</span> [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c]</span> {<span class="kw">:y</span> <span class="dv">42</span>}]) <span class="co">;=&gt; (1 3 1)</span></code></pre>
</section>
<p><section class="alert alert-success"> Use <code>map</code> to write the function <code>(second-elements collection)</code> that takes a vector of vectors and returns a sequence of the second elements.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(second-elements [[<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">3</span> <span class="dv">4</span>]]) <span class="co">;=&gt; (2 3 4)</span>
(second-elements [[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] [<span class="dv">1</span>] [<span class="st">&quot;a&quot;</span> <span class="st">&quot;s&quot;</span> <span class="st">&quot;d&quot;</span> <span class="st">&quot;f&quot;</span>]])
<span class="co">;=&gt; (2 nil &quot;s&quot;)</span></code></pre>
<p>Remember that you can use <code>get</code> to index a vector.</p>
<p>Use <code>fn</code> and <code>let</code> to create a helper function and use it with <code>map</code>.</p>
</section>
<p><section class="alert alert-success"> Write the function <code>(titles books)</code> that takes a collection of books and returns their titles.</p>
<p>Using our earlier examples:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
             <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>,
                  <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>,
                           <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown])</code></pre>
<p><code>titles</code> should work like this:</p>
<pre><code>(titles [cities]) ;=&gt; (&quot;The City and the City&quot; )
(titles books)    ;=&gt; (&quot;The City and the City&quot; &quot;Wild Seed&quot; &quot;Embassytown&quot;)</code></pre>
<p>Remember that you can use <code>:keywords</code> as functions.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">:name</span> {<span class="kw">:name</span> <span class="st">&quot;MEEEE&quot;</span>, <span class="kw">:secret</span> <span class="st">&quot;Awesome&quot;</span>}) <span class="co">;=&gt;  &quot;MEEEE&quot;</span></code></pre>
</section>
<p>We can now almost undestand the definition of <code>all-author-names</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>Let's try it out without the mysterious <code>set</code>.</p>
<p>We had these example books:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
             <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>,
                <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
                         <span class="kw">:birth-year</span> <span class="dv">1947</span>
                         <span class="kw">:death-year</span> <span class="dv">2006</span>}})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>,
                  <span class="kw">:author</span> {<span class="kw">:name</span> <span class="st">&quot;China MiÃ©ville&quot;</span>,
                           <span class="kw">:birth-year</span> <span class="dv">1972</span>}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown])</code></pre>
<p>And if we define <code>all-author-names</code> without <code>set</code>, we have:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">map</span> author-name books)))</code></pre>
<p>Here is how it works:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(all-author-names books) <span class="co">;=&gt; (&quot;China MiÃ©ville&quot; &quot;Octavia E. Butler&quot; &quot;China MiÃ©ville&quot;)</span></code></pre>
<p>We had two books by China MiÃ©ville, so his name is in the resulting sequence twice. But when we want to see the authors, we are usually not interested in duplicates. So lets turn the sequence into a data structure that supports this.</p>
</section>
<section class="level3" id="set">
<h3>Set</h3>
<p>Our last major data structure is set. It is an unordered collection of items without duplicates.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">set</span> [<span class="st">&quot;^^&quot;</span> <span class="st">&quot;^^&quot;</span> <span class="st">&quot;^__*__^&quot;</span>]) <span class="co">;=&gt; #{&quot;^__*__^&quot; &quot;^^&quot;}</span>
(<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">;=&gt; #{1 2 3}</span></code></pre>
<p>The textual form of sets is <code>#{an-elem another-elem ...}</code> and you can convert another collection into a set with the function <code>set</code>.</p>
<p>Sets have three basic operations:</p>
<p>You can check whether a set contains an element with the function <code>contains?</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> games </span>#{<span class="st">&quot;Portal&quot;</span>, <span class="st">&quot;Planescape: Torment&quot;</span>,
             <span class="st">&quot;Machinarium&quot;</span>, <span class="st">&quot;Alpha Protocol&quot;</span>})

(<span class="kw">contains?</span> games <span class="st">&quot;Portal&quot;</span>) <span class="co">;=&gt; true</span>
(<span class="kw">contains?</span> games <span class="st">&quot;RAGE&quot;</span>)   <span class="co">;=&gt; false</span>
(<span class="kw">contains?</span> games <span class="dv">42</span>)       <span class="co">;=&gt; false</span></code></pre>
<p><code>(conj set elem)</code> adds elem to <code>set</code> if it does not already have <code>elem</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:EEEEE)</span> <span class="co">;=&gt; #{:a :c :b :EEEEE}</span>
(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:a)</span>     <span class="co">;=&gt; #{:a :c :b}</span>
(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:d</span> <span class="kw">:e)</span>  <span class="co">;=&gt; #{:a :c :b :d :e}</span></code></pre>
<p>Finally, <code>(disj set elem)</code> removes <code>elem</code> from <code>set</code> if it contains <code>elem</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:c)</span> <span class="co">;=&gt; #{:a :b}</span>
(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:EEEEE)</span> <span class="co">;=&gt; #{:a :c :b}</span>
(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c}</span> <span class="kw">:c</span> <span class="kw">:a)</span> <span class="co">;=&gt; #{:b}</span></code></pre>
<p>TODO: LOL joku settitehtÃ¤vÃ¤ tÃ¤hÃ¤n?</p>
<p>xxxxxx marks the SPOT</p>
<p>TODO: wrap this shit together</p>
<p>Glorious recap:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-name (<span class="kw">fn</span> [book] (<span class="kw">:name</span> (<span class="kw">:author</span> book)))]
    (<span class="kw">set</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p>TODO;: KIRJALISTAT TÃ„HÃ„NQI</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(all-author-names books) <span class="co">;=&gt; #{&quot;China MiÃ©ville&quot; &quot;Octavia E. Butler&quot;}</span></code></pre>
<p>TODO: filter, mapv, filterv, lisÃ¤Ã¤ sovellutusta</p>
<p>TODO: kirjakamaa: vektorillinen kirjoja ja niihin liittyviÃ¤ apufunktioita, paloittele Conania tÃ¤nne sekaan.</p>
<p>TODO: do this stuff with a json api: see org.clojure/data.json and e.g. api.clojuredocs.org</p>
</section>
</section>
<section class="level2" id="sequences-1">
<h2>Sequences</h2>
<p>Do we want to speak about sequences here?</p>
</section>
<section class="level2" id="lists">
<h2>Lists</h2>
<p>Should we talk about lists?</p>
<p>Lists are :</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>)
(<span class="kw">get</span> <span class="st">&quot;Foobar&quot;</span> <span class="dv">3</span>)</code></pre>
<p>When a list is evaluated, the first element (the <em>head</em>) is resolved to a function and called, with the other items given to the function as arguments.</p>
</section>

</body>
</html>
