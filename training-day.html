<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="120 hour epic">
  <title>Training day</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
</head>
<body>
<div class="container-fluid">
    <div class="row-fluid">
        <div class="span12">
<header>
<h1 class="title">Training day</h1>
<h2 class="author">120 hour epic</h2>
<h3 class="date">sax marathon</h3>
</header>
<h2 id="synopsis">Synopsis</h2>
<blockquote>
<p>In which we learn to butt.</p>
</blockquote>
<ul>
<li>Using the REPL</li>
<li>Prefix syntax (+, -, /, *)</li>
<li>Editor</li>
<li>Declaring functions</li>
<li><code>if</code> and truthiness</li>
<li>Everything is an expression / has a value</li>
</ul>
<h2 id="interactive-clojure">Interactive Clojure</h2>
<p>To start an interactive Clojure session, type <code>lein repl</code> in the terminal.</p>
<p>It should look something like this:</p>
<pre><code>REPL started; server listening on localhost port 3099
user=&gt;</code></pre>
<p><section class="alert alert-error"> TODO: tarkista et varmasti näyttää windozella samalta </section></p>
<p>If you type <code>(+ 1 2)</code> and press the return key, you should see this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>)
<span class="dv">3</span>
user=&gt;</code></pre>
<p>Clojure evaluated the expression <code>(+ 1 2)</code> and printed its value, <code>3</code>. If you see something different, please let us know by raising your hand.</p>
<h2 id="prefix-syntax">Prefix Syntax</h2>
<blockquote>
<p>I used to be an adventurer like you, but then I took an arrow in the knee.</p>
</blockquote>
<p>As you can see above, instead of writing <code>1 + 2</code> to calculate the sum of one and two, we write <code>(+ 1 2)</code>. This syntax applies everywhere in Clojure. In fact, Clojure has no operators at all. For an example, in languages such as Java or C, arithmetic operations are usually written in the mathematical notation called <em>infix form</em>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Java</th>
<th style="text-align: left;">Clojure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2 + 3</code></td>
<td style="text-align: left;"><code>(+ 2 3)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>42 * 7</code></td>
<td style="text-align: left;"><code>(* 42 7)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2 - 78 * 35</code></td>
<td style="text-align: left;"><code>(- 2 (* 78 35))</code></td>
</tr>
</tbody>
</table>
<!-- `* -->

<p>This syntax is called <em>prefix form</em>. All Clojure syntax is of this basic form.</p>
<p>Let's input these definitions in our Clojure session to see how they work:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">3</span>)
<span class="dv">5</span>
user=&gt; (<span class="kw">*</span> <span class="dv">42</span> <span class="dv">7</span>)
<span class="dv">294</span>
user=&gt; (<span class="kw">-</span> <span class="dv">2</span> (<span class="kw">*</span> <span class="dv">78</span> <span class="dv">35</span>))
-<span class="dv">2728</span></code></pre>
<p><section class="exercise alert alert-success"> <em>Exercise:</em> Write the following expression in the Clojure prefix syntax: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>*</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn></mrow></math>. Try evaluating it in the interactive session. The result should be 10. </section></p>
<p>As an example, let's take a look at getting a single character from a string in Clojure and Java. In Clojure, we can use the <code>get</code> function for this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">get</span> <span class="st">&quot;Clojure&quot;</span> <span class="dv">2</span>) <span class="co">;=&gt; \o</span></code></pre>
<p>The result is the character <code>o</code>, printed in Clojure's literal character syntax.</p>
<p>In Java, we reorder things a bit: the first parameter goes <em>before</em> the method name, and the parentheses are moved <em>after</em> the method name:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="st">&quot;Java&quot;</span>.<span class="fu">charAt</span>(<span class="dv">2</span>); <span class="co">//=&gt; v</span></code></pre>
<p>The Clojure prefix syntax might take some time to get used to, but becomes natural after you've written a few programs in it.</p>
<h2 id="notation">Notation</h2>
<p>In our example code, we often want to show the result of an expression when it is evaluated. Instead of showing what evaluating the expression in the interactive session looks like:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>)
<span class="dv">7</span></code></pre>
<p>We're going to use the convention of writing the expression and the result, separated with <code>;=&gt;</code>. For an example:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;=&gt; 7</span></code></pre>
<p>Sometimes we will put the result on a new line:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">str</span> <span class="dv">1337</span>)
<span class="co">;=&gt; &quot;1337&quot;</span></code></pre>
<p><aside class="alert alert-info"> <code>str</code> is a function that turns its argument to a string. If given multiple arguments, it concatenates the results:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">str</span> <span class="st">&quot;Over &quot;</span> <span class="dv">9000</span> <span class="st">&quot;!&quot;</span>) <span class="co">;=&gt; &quot;Over 9000!&quot;</span></code></pre>
</aside>
<p>When the resulting value is too long to display on one line, we will mark the continuation lines with a leading <code>;</code> like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">take</span> <span class="dv">20</span> (<span class="kw">cycle</span> [<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span>]))
<span class="co">;=&gt; (&quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;</span>
<span class="co">;    &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;)</span></code></pre>
<p><code>;</code> starts a comment that lasts until the end of that line, like <code>//</code> in Java. The <code>=&gt;</code> inside the comment is an illustration of an arrow, meaning &quot;evaluates to&quot;. You can copy the examples above to the REPL and they will work without modification:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>)
<span class="dv">7</span>
user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;=&gt; 7</span>
<span class="dv">7</span>
user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">; I am a comment</span>
<span class="dv">7</span></code></pre>
<h2 id="files-and-namespaces">Files and Namespaces</h2>
<blockquote>
<p>In space no one can hear you quark.</p>
</blockquote>
<p>Code in Clojure projects is structured into separate files. Usually each file corresponds to a namespace identified by the file's path. For an example, the file <code>foo/bar/baz.clj</code> contains the namespace <code>foo.bar.baz</code>. This is slightly different from Java, where directories correspond to namespaces (packages) and files under a directory usually contain a single class in the given package.</p>
<p>Let's create the basic structure for a project to get a feeling for how this works. As you read the description below, execute the same steps on your own computer.</p>
<p>Suppose we start a project called <code>foobar</code>. First, we create the basic directory structure with an example file:</p>
<pre><code>. foobar
+-. example/
  +- hello.clj</code></pre>
<p>Here <code>hello.clj</code> is under the directory <code>example</code>, which means it contains the namespace <code>example.hello</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> example.hello)

(<span class="kw">println</span> <span class="st">&quot;O HAI!&quot;</span>)</code></pre>
<p>Namespaces are declared with <code>ns</code>.</p>
<p>Now, we go to the directory <code>foobar</code> in a terminal and start an interactive session there:</p>
<pre><code>$ cd foobar
$ lein2 repl
…
user=&gt;</code></pre>
<p>We can now load the <code>hello.clj</code> file into the session:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> &#39;example.hello)
O HAI!    <span class="co">; ← (println &quot;O HAI!&quot;)</span>
nil       <span class="co">; ← result of use</span></code></pre>
<p>This loaded the file <code>hello.clj</code> into the interactive session. Doing this, it evaluated everything in the file, which is why we see the printed line. The result of <code>use</code> itself is <code>nil</code>, a special value like Java's <code>null</code>.</p>
<aside class="alert alert-error">
<p>The <code>'</code> before the namespace name in a <code>use</code> is important. If you forget it, you will get an error like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> example.hello)
java.lang.ClassNotFoundException: example.hello (NO_SOURCE_FILE<span class="kw">:1)</span></code></pre>
<p><code>'</code> is an alias for the <code>quote</code> special form, which we will talk more about later.</p>
</aside>
<h2 id="functions">Functions</h2>
<p>So far we've worked with expressions and simple names defined with <code>def</code>. For structuring any kind of non-trivial programs, we will want to group code into <em>functions</em>.</p>
<p>Functions are written in source files, and we have one ready, <code>hello.clj</code>, so let's write the following function definition in that file. Functions are defined with <code>defn</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> hello </span>[who]
  (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>))</code></pre>
<p>Write this function to the <code>hello.clj</code> file.</p>
<p>Let's look at that again, now with running commentary alongside:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu">                       </span><span class="co">; Start a function definition:</span>
  hello                     <span class="co">; name</span>
  [who]                     <span class="co">; parameters inside brackets</span>
  (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>))  <span class="co">; body</span></code></pre>
<p>Here <code>hello</code> is the name of the function, <code>[who]</code> is the parameter list, and the expression on the second line is the body of the function. For comparison, our function looks like this in Java:</p>
<pre class="sourceCode java"><code class="sourceCode java">String <span class="fu">hello</span>(String who) {
    <span class="kw">return</span> <span class="st">&quot;Hello, &quot;</span> + who + <span class="st">&quot;!&quot;</span>;
}</code></pre>
<p>Now, let's try calling our function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> &#39;example.hello <span class="kw">:reload)</span>
user=&gt; (hello <span class="st">&quot;Metropolia&quot;</span>)
<span class="st">&quot;Hello, Metropolia!&quot;</span></code></pre>
<p>First we import the <code>example.hello</code> namespace, and tell Clojure to <em>reimport</em> it if it is already imported, so we actually see the new function definition. We then call the function with the parameter <code>&quot;Metropolia&quot;</code>. Calling the function evaluated its body with <code>who</code> bound to <code>&quot;Metropolia&quot;</code>. We can imagine the evaluator doing something like the following:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(hello <span class="st">&quot;Metropolia&quot;</span>)
<span class="co">;=&gt; (str &quot;Hello, &quot; &quot;Metropolia&quot; &quot;!&quot;)</span>
<span class="co">;=&gt; &quot;Hello, Metropolia!&quot;</span></code></pre>
<p>We now know all the basics of structuring Clojure programs.</p>
<h2 id="we-come-gifting-bears">We come gifting bears</h2>
<p>We will now move to a Leiningen-based project structure instead of the one we manually created above. It contains unit tests for the exercises that will follow. No worries, though: you can use <a href="http://git-scm.com">Git</a> to get a ready-made structure we have lovingly hand-crafted just for you:</p>
<pre><code>$ git clone https://github.com/iloveponies/training-day.git
Cloning into &#39;training-day&#39;…
…more output…
$ cd training-day
$ lein2 midje
TODO: failing test output</code></pre>
<p>Our project uses the <a href="https://github.com/marick/Midje">Midje</a> testing library. Let's take a look at what kind of tests the project contains. Open the file <code>test/training_day_test.clj</code>. The first ten lines or so of the file look like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> training-day-test
  (<span class="kw">:use</span> training-day
        midje.sweet))

(facts
  (square <span class="dv">2</span>) =&gt; <span class="dv">4</span>
  (square <span class="dv">3</span>) =&gt; <span class="dv">9</span>)</code></pre>
<p>You can ignore the namespace declaration (<code>(ns …)</code>) for now. Look at the <code>facts</code> expression. It declares some properties of the <code>square</code> function. In fact, <code>square</code> is our first exercise! After writing the implementation of <code>square</code> in <code>src/training_day.clj</code>, run <code>lein2 midje</code> again to see if your implementation agrees with the facts declared in our test file.</p>
<section class="exercise alert alert-success">
<p><em>Exercise:</em> Write a function <code>square</code> that takes a number as a parameter and multiplies it with itself.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(square <span class="dv">2</span>) <span class="co">;=&gt; 4</span>
(square <span class="dv">3</span>) <span class="co">;=&gt; 9</span></code></pre>
</section>
<p><section class="alert alert-error"> TODO: markdown-esikääntäjä tehtävänannoille </section></p>
<p><section class="alert alert-error"> TODO: joku muukin tehtävä funktioista tähän tai kohta, esim useampi parametri </section></p>
<p><section class="alert alert-error"> TODO: doc </section></p>
<p><section class="alert alert-error"> TODO: lein-shit ja testien ajaminen </section></p>
<h2 id="if-then-else">If then else</h2>
<blockquote>
<p>Any program is only as good as it is useful. <small>Linus Torvalds</small></p>
</blockquote>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">if</span> (my-father? darth-vader)
  (lose-hand me)
  (gain-hat me))</code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sign </span>[x]
  (<span class="kw">if</span> (<span class="kw">&lt;</span> <span class="dv">0</span> x)
    <span class="st">&quot;-&quot;</span>
    <span class="st">&quot;+&quot;</span>))</code></pre>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> &#39;if-then-else <span class="kw">:reload)</span>
nil
user=&gt; (sign -<span class="dv">42</span>)
<span class="st">&quot;-&quot;</span>
user=&gt; (sign <span class="dv">0</span>)
<span class="st">&quot;+&quot;</span></code></pre>
<section class="exercise alert alert-success">
<p>Write the function <code>(abs n)</code>, which returns the absolute value of <code>n</code>, i.e. if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>&lt;</mo><mn>0</mn></mrow></math>, the value of <code>(abs n)</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mi>n</mi></mrow></math>, and otherwise <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>.</p>
</section>
<p><section class="alert alert-error"> TODO: <code>mod</code> </section></p>
<section class="exercise alert alert-success">
<p>Write the function <code>(fizzbuzz n)</code> that returns</p>
<ul>
<li><code>&quot;fizz&quot;</code> when <code>n</code> is divisible by 3,</li>
<li><code>&quot;buzz&quot;</code> when <code>n</code> is divisible by 5,</li>
<li>but <em>only</em> <code>&quot;gotcha!&quot;</code> when <code>n</code> is divisible by 15.</li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(fizzbuzz <span class="dv">45</span>) <span class="co">;=&gt; &quot;gotcha!&quot;</span>
(fizzbuzz <span class="dv">48</span>) <span class="co">;=&gt; &quot;fizz&quot;</span>
(fizzbuzz <span class="dv">70</span>) <span class="co">;=&gt; &quot;buzz&quot;</span></code></pre>
</section>
<p><section class="alert alert-error"> TODO: literate clojure </section></p>
<p><section class="alert alert-error"> TODO?: lein projektit </section></p>
</div>
</div>
</div>
</body>
</html>
