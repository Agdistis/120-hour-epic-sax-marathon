<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="120 hour epic">
  <title>Training day</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
    q { quotes: "“" "”" "‘" "’"; }
  </style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <script src="https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
</head>
<body>
<div class="container-fluid">
<div class="row-fluid">
<div class="span12"><div class="top-nav"><a href="index.html">← index</a></div>
<header>
<h1 class="title">Training day</h1>
<h2 class="author">120 hour epic</h2>
<h3 class="date">sax marathon</h3>
</header>
<section class="level2" id="synopsis">
<h2>Synopsis</h2>
<p>A whirlwind tour of the basics of Clojure, including:</p>
<ul>
<li>Using the REPL</li>
<li>Prefix syntax</li>
<li>Defining functions</li>
</ul>
</section>
<section class="level2" id="interactive-clojure">
<h2>Interactive Clojure</h2>
<section class="level3" id="light-table">
<h3>Light Table</h3>
<p>Did you choose Light Table as your editor? Actually, you should test it in any case. It’s pretty awsome. Follow the installation instructions found <a href="http://app.kodowa.com/playground">here</a> if you haven’t already. In Linux, you run the <code>launcher.jar</code> as you would run any .jar file and then navigate to <code>localhost:8833</code> in Chrome (or Chromium). Select Instarepl when confronted with the choice.</p>
<p>On the left side you have a box. Click under the last line of text, press <code>Enter</code> to get some breathing space and type <code>(+ 1 2)</code>. The answer should appear as the last line on the right hand side like this</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>) =&gt; <span class="dv">3</span></code></pre>
<p>If something went sideways, please let us know by raising your hand.</p>
</section>
<section class="level3" id="good-ol-repl">
<h3>Good ol’ repl</h3>
<p>If you don’t want to use Light Table, there is always the <code>lein repl</code>. Issue that command in the terminal and a interactive Clojure session starts. It should look like this:</p>
<pre><code>me@my-computer:~$ lein repl
nREPL server started on port 50443
Welcome to REPL-y!
Clojure 1.4.0
    Exit: Control+D or (exit) or (quit)
Commands: (user/help)
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
          (user/sourcery function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
Examples from clojuredocs.org: [clojuredocs or cdoc]
          (user/clojuredocs name-here)
          (user/clojuredocs &quot;ns-here&quot; &quot;name-here&quot;)
user=&gt;</code></pre>
<p>If you type <code>(+ 1 2)</code> and press the return key, you should see this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span>)
<span class="dv">3</span>
user=&gt;</code></pre>
<p>Clojure evaluated the expression <code>(+ 1 2)</code> and printed its value, <code>3</code>. If you see something different, please let us know by raising your hand.</p>
</section>
</section>
<section class="level2" id="notation">
<h2>Notation</h2>
<p>In our example code, we often want to show the result of an expression when it is evaluated. Instead of showing what evaluating the expression in the interactive session looks like:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>)
<span class="dv">7</span></code></pre>
<p>We’re going to use the convention of writing the expression and the result, separated with <code>;=&gt;</code>. Quite like how Light Table does it. For an example:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;=&gt; 7</span></code></pre>
<p>Sometimes we will put the result on a new line:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">str</span> <span class="dv">1337</span>)
<span class="co">;=&gt; &quot;1337&quot;</span></code></pre>
<section class="alert alert-info">
<h3>
Hint
</h3>
<p><code>str</code> is a function that turns its argument to a string. If given multiple arguments, it concatenates the results:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">str</span> <span class="st">&quot;Over &quot;</span> <span class="dv">9000</span> <span class="st">&quot;!&quot;</span>) <span class="co">;=&gt; &quot;Over 9000!&quot;</span></code></pre>
</section>
<p>When the resulting value is too long to display on one line, we will mark the continuation lines with a leading <code>;</code> like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">take</span> <span class="dv">20</span> (<span class="kw">cycle</span> [<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span>]))
<span class="co">;=&gt; (&quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;</span>
<span class="co">;    &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;)</span></code></pre>
<p><code>;</code> starts a comment that lasts until the end of that line, like <code>//</code> in Java. The <code>=&gt;</code> inside the comment is an illustration of an arrow, meaning <q>evaluates to</q>. You can copy the examples above to the REPL and they will work without modification:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>)
<span class="dv">7</span>
user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">;=&gt; 7</span>
<span class="dv">7</span>
user=&gt; (<span class="kw">+</span> <span class="dv">3</span> <span class="dv">4</span>) <span class="co">; I am a comment</span>
<span class="dv">7</span></code></pre>
</section>
<section class="level2" id="prefix-syntax">
<h2>Prefix Syntax</h2>
<p>As you can see above, instead of writing <code>1 + 2</code> to calculate the sum of one and two, we write <code>(+ 1 2)</code>. This syntax applies everywhere in Clojure. In fact, Clojure has no operators at all. In languages such as Java or C, arithmetic operations are usually written in the mathematical notation called <em>infix form</em>. Clojure, on the other hand, uses <em>prefix form</em> for its syntax. The next table shows what mathematical expressions look like in these two syntaxes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Java</th>
<th style="text-align: left;">Clojure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>2 + 3</code></td>
<td style="text-align: left;"><code>(+ 2 3)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>42 * 7</code></td>
<td style="text-align: left;"><code>(* 42 7)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>2 - 78 * 35</code></td>
<td style="text-align: left;"><code>(- 2 (* 78 35))</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1 + 2 + 3 + 4</code></td>
<td style="text-align: left;"><code>(+ 1 2 3 4)</code></td>
</tr>
</tbody>
</table>
<p>Let’s input these definitions in our Clojure session to see how they work:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">3</span>)
<span class="dv">5</span>
user=&gt; (<span class="kw">*</span> <span class="dv">42</span> <span class="dv">7</span>)
<span class="dv">294</span>
user=&gt; (<span class="kw">-</span> <span class="dv">2</span> (<span class="kw">*</span> <span class="dv">78</span> <span class="dv">35</span>))
-<span class="dv">2728</span>
user=&gt; (<span class="kw">+</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)
<span class="dv">10</span></code></pre>
<section class="alert alert-success">
<h3>
Exercise 1
</h3>
<p>Write the following expression in the Clojure prefix syntax: \((2 * 3) + 4\). Try evaluating it in the interactive session. The result should be 10.</p>
</section>
<section class="alert alert-success">
<h3>
Exercise 2
</h3>
<p>Write the expression \(3 + 4 + 5 + 6\) in Clojure syntax. Evaluate it.</p>
</section>
<p>The arithmetic operations have some special properties. Everyone of the operations works with only one operand.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">+</span> <span class="dv">1</span>) <span class="co">;=&gt; 1</span>
(<span class="kw">*</span> <span class="dv">2</span>) <span class="co">;=&gt; 2</span>
(<span class="kw">-</span> <span class="dv">3</span>) <span class="co">;=&gt; -3</span>
(<span class="kw">/</span> <span class="dv">4</span>) <span class="co">;=&gt; 1/4</span></code></pre>
<p>This behavior might seem odd, but here is the catch. The arithmetic operations above are, in fact, function calls. That is, <code>+</code> is actually a function (called <code>+</code>), as are <code>*</code> and <code>-</code>. Don’t believe use? Write just <code>+</code> in the REPL. In Instarepl you see</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="kw">+</span> =&gt; <span class="kw">fn</span></code></pre>
<p>and in <code>lein repl</code></p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; <span class="kw">+</span>
#&lt;core$_PLUS_ clojure.core$_PLUS_<span class="kw">@2d21471c&gt;</span></code></pre>
<p>They are both telling you that <code>+</code> is just a function.</p>
<p>All function calls in Clojure look the same: <code>(function-name argument-1 argument-2 ...)</code>. As an example of a non-arithmetic function, let’s take a look at getting a single character from a string in Clojure and Java. In Clojure, we can use the <code>get</code> function for this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">get</span> <span class="st">&quot;Clojure&quot;</span> <span class="dv">2</span>) <span class="co">;=&gt; \o</span></code></pre>
<p>The result is the character <code>o</code>, printed in Clojure’s literal character syntax. (That is, <code>\o</code> in Clojure code means the single character <code>o</code>. In Java, you would write a literal character as <code>'o'</code>.)</p>
<p>In Java, we reorder things a bit: the first parameter goes <em>before</em> the method name, and the parentheses are moved <em>after</em> the method name:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="st">&quot;Java&quot;</span>.<span class="fu">charAt</span>(<span class="dv">2</span>); <span class="co">//=&gt; &#39;v&#39;</span></code></pre>
<p>In Clojure, the function name always goes first, and the parameters come after it, including the object, if such is present. The Clojure syntax might take some time to get used to, but becomes natural after you’ve written a few Clojure programs.</p>
<section class="alert alert-success">
<h3>
Exercise 3
</h3>
<p>Write a Clojure expression that, using <code>get</code>, gets the first character in the string <code>&quot;abrakadabra&quot;</code>.</p>
</section>
</section>
<section class="level2" id="functions">
<h2>Functions</h2>
<p>So far we’ve worked with expressions and called some existing functions. For structuring any kind of non-trivial programs, we will want to group code into our own <em>functions</em>.</p>
<p>Lets start writing a function <code>(hello who)</code>, which returns an English greeting for the user. Functions are created with <code>fn</code>. Write the following in you REPL and evaluate it.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">fn</span> [who] (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>))</code></pre>
<p>The REPL should tell you that it was a function. Instarepl just says</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">fn</span> [who] (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>)) =&gt; <span class="kw">fn</span></code></pre>
<p>As usual, <code>lein repl</code> is a bit more verbose and states</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">fn</span> [who] (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>))
#&lt;user$eval326$fn__327 user$eval326$fn__327<span class="kw">@4a2d09aa&gt;</span></code></pre>
<p>So what kind of a function did we actually get? Inside the square brackets are the parameters of the function. This one only has a one and we gave that a name <code>who</code>. Right after that comes comes an expression, a function call in this case. The value of this expression will become the return value of this function. In general, the return value of a function will be the value of the last expression in the function.</p>
<p>Now we know how to make a function, but we only got a glimpse of it and then it was gone. We want something more permanent, something that we can write once and call multiple times. The functions created with <code>fn</code> are called <em>anonymous functions</em>. They are named such because they have no name. To give a name to a function we can use <code>def</code>. Let’s give the function a name right away.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> hello </span>(<span class="kw">fn</span> [who] (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>)))</code></pre>
<p>Don’t forget to evaluate that one. Now we can call this function. Write <code>(hello &quot;beautiful&quot;)</code> in your REPL to get a instant compliment. In the name of sex-equality evaluate also <code>(hello &quot;handsome&quot;)</code>.</p>
<p>So what just happened? Well, <code>def</code> gives a name to a value. In the previous case the value is what we get when we evaluate <code>(fn [who] (str &quot;Hello, &quot; who &quot;!&quot;))</code>. And what do we get when we evaluate that? A function. So we gave the name <code>hello</code> to a function that gives out greetings.</p>
<p>Anonymous functions have their uses in functional programming. So it is nice to know that we can create them with <code>fn</code>. But most of the time we want to give the function a name right away. To make that a bit easier, we have <code>defn</code>. Here is how to create <em>and</em> name the previous function with <code>defn</code>. There is a running commentary alongside, to make sure we understand its parts.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu">                                 </span><span class="co">; Start a function definition:</span>
  hello                               <span class="co">; name</span>
  <span class="st">&quot;Gives out personalized greetings.&quot;</span> <span class="co">; a optional docstring</span>
  [who]                               <span class="co">; parameters inside brackets</span>
  (<span class="kw">str</span> <span class="st">&quot;Hello, &quot;</span> who <span class="st">&quot;!&quot;</span>))            <span class="co">; body</span></code></pre>
<p>Here <code>hello</code> is the name of the function, <code>[who]</code> is the parameter list, and the expression on the second line is the body of the function. The return value of the function is the value of the last expression inside the function body. In this case, it is the value of the <code>(str &quot;Hello, &quot; who &quot;!&quot;)</code> expression. We have also provided an docstring that briefly tells what this function does. This is optional, but like washing your hands after visiting the toilet, highly recommended.</p>
<p>For comparison, our function looks like this in Java:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="co">/**</span>
<span class="co"> * Gives out personalized greetings.</span>
<span class="co"> */</span>
String <span class="fu">hello</span>(String who) {
    <span class="kw">return</span> <span class="st">&quot;Hello, &quot;</span> + who + <span class="st">&quot;!&quot;</span>;
}</code></pre>
<p>Note that in Clojure, there is no <code>return</code> keyword. The return value of a function is always the value of the last expression in the function body.</p>
<section class="alert alert-info">
<h3>
Hint
</h3>
<p>Want to take a look at the docstring of some function? You can use the <code>doc</code> function to do so. Unfortunately you need to do some tricks to get your hands at this function. But don’t worry, it’s not difficult.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> &#39;clojure.<span class="kw">repl</span>)
user=&gt; (<span class="kw">doc</span> <span class="kw">+</span>)
-------------------------
clojure.core/+
([] [x] [x y] [x y &amp; more])
  Returns the sum of nums. (<span class="kw">+</span>) returns <span class="dv">0</span>. Does <span class="kw">not</span> auto-promote
  <span class="kw">longs</span>, will <span class="kw">throw</span> on overflow. See also: +&#39;
nil</code></pre>
<p>You can also see the docstring of our <code>hello</code> function. Evaluate the following in your REPL.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">use</span> &#39;clojure.<span class="kw">repl</span>)
(<span class="kw">doc</span> hello)</code></pre>
<p>The next section will tell you more about the function <code>use</code>.</p>
</section>
</section>
<section class="level2" id="files-and-namespaces">
<h2>Files and Namespaces</h2>
<p>Code in Clojure projects is structured into separate files. Usually each file corresponds to a namespace identified by the file’s path. For an example, the file <code>foo/bar/baz.clj</code> contains the namespace <code>foo.bar.baz</code>. This is slightly different from Java, where directories correspond to namespaces (packages) and files under a directory usually contain a single class in the given package.</p>
<p>Let’s create the basic structure for a project to get a feeling for how this works. As you read the description below, execute the same steps on your own computer.</p>
<p>Suppose we start a project called <code>foobar</code>. First, we create the basic directory structure with an example file:</p>
<pre><code>me@my-computer:~$ mkdir foobar
me@my-computer:~$ cd foobar
me@my-computer:~/foobar$ mkdir example
me@my-computer:~/foobar$ cd example/
me@my-computer:~/foobar/example$ touch hello.clj</code></pre>
<p>This will result in the following directory structure:</p>
<pre><code>. foobar
+-. example/
  +- hello.clj</code></pre>
<p>Here <code>hello.clj</code> is under the directory <code>example</code>, which means it should contain the namespace <code>example.hello</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> example.hello)

(<span class="kw">println</span> <span class="st">&quot;O HAI!&quot;</span>)</code></pre>
<p>Namespaces are declared with <code>ns</code>. Write this in EVim and save the file.</p>
<p>We can now go back to the <code>foobar</code> directory and start an interactive Clojure session in the project:</p>
<pre><code>me@my-computer:~/foobar/example$ cd ..
me@my-computer:~/foobar$ lein repl
nREPL server started on port 39455
Welcome to REPL-y!
Clojure 1.4.0
    Exit: Control+D or (exit) or (quit)
Commands: (user/help)
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
          (user/sourcery function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
Examples from clojuredocs.org: [clojuredocs or cdoc]
          (user/clojuredocs name-here)
          (user/clojuredocs &quot;ns-here&quot; &quot;name-here&quot;)
nil
user=&gt;</code></pre>
<p>We can now load the <code>hello.clj</code> file into the session:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> &#39;example.hello)
O HAI!    <span class="co">; ← (println &quot;O HAI!&quot;)</span>
nil       <span class="co">; ← result of use</span></code></pre>
<p>This loaded the file <code>hello.clj</code> into the interactive session. Doing this, it evaluated everything in the file, which is why we see the printed line. The result of <code>use</code> itself is <code>nil</code>, a special value like Java’s <code>null</code>.</p>
<section class="alert alert-error">
<h3>
Watch out!
</h3>
<p>The <code>'</code> before the namespace name in a <code>use</code> is important. If you forget it, you will get an error like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">use</span> example.hello)
java.lang.ClassNotFoundException: example.hello (NO_SOURCE_FILE<span class="kw">:1</span>)</code></pre>
<p><code>'</code> is an alias for the <code>quote</code> special form, which we will talk more about later.</p>
</section>
</section>
<section class="level2" id="we-come-gifting-bears">
<h2>We come gifting bears</h2>
<blockquote>
<p>When in doubt, do exactly the opposite of CVS. <small>Linus Torvalds</small></p>
</blockquote>
<p>We will now move to a Leiningen-based project structure instead of the one we manually created above. It contains unit tests for the exercises that will follow. No worries, though: you can use <a href="http://git-scm.com">Git</a> to get a ready-made structure we have lovingly hand-crafted just for you:</p>
<pre><code>me@my-computer:~$ git clone https://github.com/iloveponies/training-day.git
Cloning into &#39;training-day&#39;...
remote: Counting objects: 18, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 18 (delta 5), reused 17 (delta 4)
Unpacking objects: 100% (18/18), done.</code></pre>
<p>You now have your own copy of the project that we will use for writing the exercises in this chapter.</p>
<p>Let’s run the unit tests first. This will output a <em>lot</em> of somewhat superfluous information while Leiningen downloads the project dependencies, so you will see more output printed than what is shown below. This output is printed only once, so subsequent runs will not be so chatty.</p>
<pre><code>me@my-computer:~$ cd training-day/
me@my-computer:~/training-day$ lein midje</code></pre>
<p>Leiningen tells us it’s downloading the whole internet:</p>
<pre><code>Could not find metadata lein-midje:lein-midje:2.0.0-SNAPSHOT/maven-metadata.xml in central (http://repo1.maven.org/maven2)
Retrieving lein-midje/lein-midje/2.0.0-SNAPSHOT/maven-metadata.xml (1k)
    from http://clojars.org/repo/
Could not find metadata lein-midje:lein-midje:2.0.0-SNAPSHOT/maven-metadata.xml in stuart (http://stuartsierra.com/maven2)
Could not find artifact midje:midje:pom:1.4.0 in central (http://repo1.maven.org/maven2)
Retrieving midje/midje/1.4.0/midje-1.4.0.pom (5k)from http://clojars.org/repo/

…Skip…</code></pre>
<p>And finally, the output we are interested in:</p>
<pre><code>FAIL &quot;square&quot; at (training_day_test.clj:6)
    Expected: 4
      Actual: &quot;:(&quot;

FAIL &quot;square&quot; at (training_day_test.clj:7)
    Expected: 9
      Actual: &quot;:(&quot;

FAIL &quot;average&quot; at (training_day_test.clj:19)
    Expected: 3
      Actual: &quot;:(&quot;

FAIL &quot;average&quot; at (training_day_test.clj:20)
    Expected: 3/2
      Actual: &quot;:(&quot;
FAILURE: 9 facts were not confirmed.
me@my-computer:~/training-day$</code></pre>
<p>Our project uses the <a href="https://github.com/marick/Midje">Midje</a> testing library. Let’s take a look at what kind of tests the project contains. Open the file <code>test/training_day_test.clj</code>. The first ten lines or so of the file look like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> training-day-test
  (<span class="kw">:use</span> training-day
        midje.sweet))

(facts <span class="st">&quot;square&quot;</span>
  (square <span class="dv">2</span>) =&gt; <span class="dv">4</span>
  (square <span class="dv">3</span>) =&gt; <span class="dv">9</span>)</code></pre>
<p>The <code>facts</code> form declares some facts of the <code>square</code> function. A fact, in Midje, is an expression <code>expr =&gt; expected-value</code>, saying <q>Evaluating <code>expr</code> should return <code>expected-value</code></q>. Our two tests (or facts) say that <code>(square 2)</code> should return <code>4</code> and <code>(square 3)</code> should return 9.</p>
<p>If you take a look at the file <code>src/training-day.clj</code>, you will see that we’ve provided a stub for the <code>square</code> function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> square </span>[n]
  <span class="st">&quot;:(&quot;</span>)</code></pre>
<p>Our stub simply returns the string <code>&quot;:(&quot;</code> for all values of <code>n</code>. This does not pass the tests, which we saw above. The relevant output was:</p>
<pre><code>FAIL &quot;square&quot; at (training_day_test.clj:6)
    Expected: 4
      Actual: &quot;:(&quot;

FAIL &quot;square&quot; at (training_day_test.clj:7)
    Expected: 9
      Actual: &quot;:(&quot;</code></pre>
<p>The <code>FAIL</code> lines indicate that our stub function fails the tests as expected, because the string <code>&quot;:(&quot;</code> is not <code>4</code> or <code>9</code>.</p>
<p>The first exercise, then, is to implement <code>square</code>.</p>
<p>After writing the implementation of <code>square</code> in <code>src/training_day.clj</code>, run <code>lein midje</code> again to see if your implementation agrees with the facts declared in our test file.</p>
<section class="alert alert-success">
<h3>
Exercise 4
</h3>
<p>Write the function <code>(square x)</code> that takes a number as a parameter and multiplies it with itself.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(square <span class="dv">2</span>) <span class="co">;=&gt; 4</span>
(square <span class="dv">3</span>) <span class="co">;=&gt; 9</span></code></pre>
</section>
<section class="alert alert-success">
<h3>
Exercise 5
</h3>
<p>Write the function <code>(average a b)</code>, which returns the average of its two parameters:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(average <span class="dv">2</span> <span class="dv">4</span>) <span class="co">;=&gt; 3</span>
(average <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;=&gt; 3/2</span></code></pre>
</section>
<section class="alert alert-info">
<h3>
Hint
</h3>
<p>You can use <code>(doc function)</code> to see some documentation for <code>function</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">doc</span> <span class="kw">max</span>)
-------------------------
clojure.core/max
([x] [x y] [x y &amp; more])
  Returns the greatest of the nums.
nil</code></pre>
<p>You can also use <code>(user/clojuredocs function)</code> to see some examples for <code>function</code></p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (user/clojuredocs <span class="kw">min</span>)
========== vvv Examples ================
  user=&gt; (<span class="kw">min</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)  
  <span class="dv">1</span>
  user=&gt; (<span class="kw">min</span> <span class="dv">5</span> <span class="dv">4</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>)
  <span class="dv">1</span>
  user=&gt; (<span class="kw">min</span> <span class="dv">100</span>)
  <span class="dv">100</span>
========== ^^^ Examples ================
<span class="dv">1</span> example found <span class="kw">for</span> clojure.core/min
nil</code></pre>
</section>
<p><a href="I-am-a-horse-in-the-land-of-booleans.html">Proceed to the horse feast! →</a></p>
</section>
<footer>
    <p>
        &copy; <a href="http://iloveponies.github.com">iloveponies</a>.

        <span style="float: right">
            <a href="mailto:ilmari.vacklin@gmail.com">questions?</a>
        </span>
    </p>
</footer>
</div>
</div>
</div>
</body>
</html>
